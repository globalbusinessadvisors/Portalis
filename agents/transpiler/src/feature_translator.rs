//! Feature-based Python to Rust translator
//!
//! Complete translation pipeline: Python source → AST → Rust code
//! Implements the 527 Python language features, starting with Low complexity.

use crate::python_to_rust::PythonToRustTranslator;
use crate::python_ast::{PyModule, PyStmt};
use crate::simple_parser::SimplePythonParser;
use crate::indented_parser::IndentedPythonParser;
use crate::stdlib_mapper::StdlibMapper;
use crate::Result;
use std::collections::HashMap;

/// Complete Python → Rust translation pipeline
pub struct FeatureTranslator {
    translator: PythonToRustTranslator,
    stdlib_mapper: StdlibMapper,
}

impl FeatureTranslator {
    pub fn new() -> Self {
        Self {
            translator: PythonToRustTranslator::new(),
            stdlib_mapper: StdlibMapper::new(),
        }
    }

    /// Translate Python source code to Rust
    ///
    /// # Supported Features
    /// Day 2 (10): Literals, assignments, operators, print, comments
    /// Day 3 (15): Comparison/logical ops, lists, tuples, pass/break/continue
    /// Day 4-5 (10+): Control flow, loops, functions, more operators
    /// Import system: import math, from os import path, etc.
    pub fn translate(&mut self, python_source: &str) -> Result<String> {
        // Use indented parser for multi-line support
        let mut parser = IndentedPythonParser::new(python_source);
        let ast = parser.parse()?;

        // Extract imports and aliases
        let imports = self.extract_imports(&ast);
        let aliases = self.extract_aliases(&ast);
        let use_statements = self.stdlib_mapper.collect_use_statements(&imports);

        // Pass imports and aliases to translator for attribute resolution
        self.translator.set_imports(imports.clone());
        self.translator.set_aliases(aliases);

        // Generate Rust code from AST
        let mut rust_code = self.translator.translate_module(&ast)?;

        // Prepend use statements if there are imports
        if !use_statements.is_empty() {
            let mut final_code = String::from("// Generated by Portalis Python → Rust Translator\n#![allow(unused)]\n\n");
            for use_stmt in use_statements {
                final_code.push_str(&use_stmt);
                final_code.push('\n');
            }
            final_code.push('\n');

            // Remove the header from rust_code if it exists
            if rust_code.starts_with("// Generated by Portalis") {
                if let Some(pos) = rust_code.find("\n\n") {
                    rust_code = rust_code[pos + 2..].to_string();
                }
            }

            final_code.push_str(&rust_code);
            rust_code = final_code;
        }

        Ok(rust_code)
    }

    /// Extract import module names from AST
    fn extract_imports(&self, module: &PyModule) -> Vec<String> {
        let mut imports = Vec::new();

        for stmt in &module.body {
            match stmt {
                PyStmt::Import { names, aliases: _ } => {
                    imports.extend(names.clone());
                }
                PyStmt::ImportFrom { module, names: _, aliases: _ } => {
                    imports.push(module.clone());
                }
                _ => {}
            }
        }

        imports
    }

    /// Extract alias mappings from AST (alias -> module)
    fn extract_aliases(&self, module: &PyModule) -> HashMap<String, String> {
        let mut aliases = HashMap::new();

        for stmt in &module.body {
            match stmt {
                PyStmt::Import { names, aliases: alias_vec } => {
                    for (i, name) in names.iter().enumerate() {
                        if let Some(Some(alias)) = alias_vec.get(i) {
                            aliases.insert(alias.clone(), name.clone());
                        }
                    }
                }
                PyStmt::ImportFrom { module, names, aliases: alias_vec } => {
                    for (i, name) in names.iter().enumerate() {
                        if let Some(Some(alias)) = alias_vec.get(i) {
                            // For from imports, alias maps to module.name
                            aliases.insert(alias.clone(), format!("{}.{}", module, name));
                        }
                    }
                }
                _ => {}
            }
        }

        aliases
    }

    /// Translate using simple parser (for single-line code)
    pub fn translate_simple(&mut self, python_source: &str) -> Result<String> {
        let mut parser = SimplePythonParser::new(python_source);
        let ast = parser.parse()?;
        self.translator.translate_module(&ast)
    }
}

impl Default for FeatureTranslator {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_translate_integer_literal() {
        let mut translator = FeatureTranslator::new();
        let python = "x = 42";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let x: i32 = 42;"));
    }

    #[test]
    fn test_translate_float_literal() {
        let mut translator = FeatureTranslator::new();
        let python = "pi = 3.14";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let pi: f64 = 3.14;"));
    }

    #[test]
    fn test_translate_string_literal() {
        let mut translator = FeatureTranslator::new();
        let python = r#"msg = "hello""#;
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains(r#"let msg: String = "hello";"#));
    }

    #[test]
    fn test_translate_boolean_literal() {
        let mut translator = FeatureTranslator::new();
        let python = "flag = True";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let flag: bool = true;"));
    }

    #[test]
    fn test_translate_simple_assignment() {
        let mut translator = FeatureTranslator::new();
        let python = "result = 100";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let result: i32 = 100;"));
    }

    #[test]
    fn test_translate_augmented_assignment() {
        let mut translator = FeatureTranslator::new();
        let python = "x += 5";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("x += 5;"));
    }

    #[test]
    fn test_translate_print() {
        let mut translator = FeatureTranslator::new();
        let python = r#"print("hello")"#;
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains(r#"print("hello");"#));
    }

    #[test]
    fn test_translate_comments_skipped() {
        let mut translator = FeatureTranslator::new();
        let python = "# Comment\nx = 42\n# Another comment";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let x: i32 = 42;"));
        assert!(!rust.contains("# Comment")); // Comments not in output
    }

    #[test]
    fn test_translate_binary_operation() {
        let mut translator = FeatureTranslator::new();
        let python = "result = 2 + 3";
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let result: i32 = 2 + 3;"));
    }

    #[test]
    fn test_translate_multiple_statements() {
        let mut translator = FeatureTranslator::new();
        let python = r#"
x = 42
y = 3.14
msg = "hello"
result = x + 5
"#;
        let rust = translator.translate(python).unwrap();

        assert!(rust.contains("let x: i32 = 42;"));
        assert!(rust.contains("let y: f64 = 3.14;"));
        assert!(rust.contains(r#"let msg: String = "hello";"#));
        assert!(rust.contains("let result: i32 = x + 5;"));
    }

    #[test]
    fn test_full_program() {
        let mut translator = FeatureTranslator::new();
        let python = r#"
# Simple calculation program
x = 10
y = 20
total = x + y
print("Result")
"#;
        let rust = translator.translate(python).unwrap();

        println!("Generated Rust code:\n{}", rust);

        assert!(rust.contains("Generated by Portalis"));
        assert!(rust.contains("let x: i32 = 10;"));
        assert!(rust.contains("let y: i32 = 20;"));
        assert!(rust.contains("let total: i32 = x + y;"));
        assert!(rust.contains(r#"print("Result");"#));
    }
}
