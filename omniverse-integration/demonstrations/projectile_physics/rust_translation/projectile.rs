// Projectile Physics Simulation - Rust Translation
// Generated by Portalis from Python source

#![no_std]

use core::f64::consts::PI;

/// Calculate projectile position at given time
///
/// # Arguments
/// * `initial_velocity` - Initial velocity in m/s
/// * `angle_degrees` - Launch angle in degrees
/// * `time` - Time since launch in seconds
/// * `gravity` - Gravitational acceleration in m/s²
///
/// # Returns
/// Tuple of (x, y, z) position in meters
#[no_mangle]
pub extern "C" fn calculate_trajectory(
    initial_velocity: f64,
    angle_degrees: f64,
    time: f64,
    gravity: f64,
) -> (f64, f64, f64) {
    // Convert angle to radians
    let angle_rad = angle_degrees * PI / 180.0;

    // Calculate velocity components
    let vx = initial_velocity * angle_rad.cos();
    let vy = initial_velocity * angle_rad.sin();

    // Calculate position
    let x = vx * time;
    let y = vy * time - 0.5 * gravity * time * time;
    let z = 0.0; // No lateral movement

    (x, y, z)
}

/// Calculate time until projectile hits ground
///
/// # Arguments
/// * `initial_velocity` - Initial velocity in m/s
/// * `angle_degrees` - Launch angle in degrees
/// * `initial_height` - Initial height above ground in meters
/// * `gravity` - Gravitational acceleration in m/s²
///
/// # Returns
/// Impact time in seconds
#[no_mangle]
pub extern "C" fn calculate_impact_time(
    initial_velocity: f64,
    angle_degrees: f64,
    initial_height: f64,
    gravity: f64,
) -> f64 {
    let angle_rad = angle_degrees * PI / 180.0;
    let vy = initial_velocity * angle_rad.sin();

    // Quadratic formula: -0.5*g*t² + vy*t + h = 0
    let a = -0.5 * gravity;
    let b = vy;
    let c = initial_height;

    let discriminant = b * b - 4.0 * a * c;

    if discriminant < 0.0 {
        return 0.0; // No real solution
    }

    // Take positive root
    let sqrt_disc = discriminant.sqrt();
    let t1 = (-b + sqrt_disc) / (2.0 * a);
    let t2 = (-b - sqrt_disc) / (2.0 * a);

    if t1 > t2 { t1 } else { t2 }
}

/// Calculate maximum height reached by projectile
///
/// # Arguments
/// * `initial_velocity` - Initial velocity in m/s
/// * `angle_degrees` - Launch angle in degrees
/// * `gravity` - Gravitational acceleration in m/s²
///
/// # Returns
/// Maximum height in meters
#[no_mangle]
pub extern "C" fn calculate_max_height(
    initial_velocity: f64,
    angle_degrees: f64,
    gravity: f64,
) -> f64 {
    let angle_rad = angle_degrees * PI / 180.0;
    let vy = initial_velocity * angle_rad.sin();

    // At max height, vertical velocity is 0
    // vy - g*t = 0 => t = vy/g
    let time_to_max = vy / gravity;

    // h = vy*t - 0.5*g*t²
    vy * time_to_max - 0.5 * gravity * time_to_max * time_to_max
}

/// Calculate horizontal range of projectile
///
/// # Arguments
/// * `initial_velocity` - Initial velocity in m/s
/// * `angle_degrees` - Launch angle in degrees
/// * `initial_height` - Initial height above ground in meters
/// * `gravity` - Gravitational acceleration in m/s²
///
/// # Returns
/// Horizontal range in meters
#[no_mangle]
pub extern "C" fn calculate_range(
    initial_velocity: f64,
    angle_degrees: f64,
    initial_height: f64,
    gravity: f64,
) -> f64 {
    let impact_time = calculate_impact_time(
        initial_velocity,
        angle_degrees,
        initial_height,
        gravity,
    );

    let angle_rad = angle_degrees * PI / 180.0;
    let vx = initial_velocity * angle_rad.cos();

    vx * impact_time
}

/// Update physics simulation - WASM entry point
///
/// This function is called from Omniverse at each frame
///
/// # Arguments
/// * `delta_time_ms` - Time since last update in milliseconds
///
/// # Returns
/// Status code (0 = success)
#[no_mangle]
pub extern "C" fn update_physics(delta_time_ms: i32) -> i32 {
    // Convert to seconds
    let _dt = delta_time_ms as f64 / 1000.0;

    // This is a simplified version for WASM
    // Real implementation would maintain state
    0
}

// Simplified trajectory calculation for WASM (returns only Y component)
#[no_mangle]
pub extern "C" fn get_trajectory_y(
    initial_velocity: f64,
    angle_degrees: f64,
    time: f64,
) -> f64 {
    let (_, y, _) = calculate_trajectory(initial_velocity, angle_degrees, time, 9.81);
    y
}

// Simplified trajectory calculation for WASM (returns only X component)
#[no_mangle]
pub extern "C" fn get_trajectory_x(
    initial_velocity: f64,
    angle_degrees: f64,
    time: f64,
) -> f64 {
    let (x, _, _) = calculate_trajectory(initial_velocity, angle_degrees, time, 9.81);
    x
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_trajectory_at_launch() {
        let (x, y, z) = calculate_trajectory(20.0, 45.0, 0.0, 9.81);
        assert_eq!(x, 0.0);
        assert_eq!(y, 0.0);
        assert_eq!(z, 0.0);
    }

    #[test]
    fn test_max_height() {
        let height = calculate_max_height(20.0, 90.0, 9.81);
        // v²/(2g) = 20²/(2*9.81) ≈ 20.39 m
        assert!((height - 20.39).abs() < 0.1);
    }

    #[test]
    fn test_range_45_degrees() {
        // 45 degrees should give maximum range
        let range = calculate_range(20.0, 45.0, 0.0, 9.81);
        // R = v²/g = 400/9.81 ≈ 40.77 m
        assert!((range - 40.77).abs() < 0.5);
    }
}
