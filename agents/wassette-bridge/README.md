# Portalis Wassette Bridge

WebAssembly runtime integration for Portalis using the Wassette WASM runtime.

## Overview

The `portalis-wassette-bridge` provides integration between the Portalis transpilation platform and Microsoft's Wassette WebAssembly runtime. This enables secure execution and validation of WebAssembly components generated by Portalis with fine-grained permission controls.

## Features

- **WASM Component Validation**: Validate WebAssembly components before deployment
- **Sandboxed Execution**: Execute WASM with browser-grade security isolation
- **Fine-grained Permissions**: Control filesystem, network, and environment access
- **Optional Runtime**: Can be used in validation-only mode without Wasmtime dependency
- **Mock-friendly**: Easy to test with mock implementations

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
portalis-wassette-bridge = "0.1.0"

# For runtime execution support
[features]
runtime = ["portalis-wassette-bridge/runtime"]
```

## Usage

### Basic Validation (No Runtime Required)

```rust
use portalis_wassette_bridge::{WassetteClient, WassetteConfig};
use std::path::Path;

// Create client with default configuration
let client = WassetteClient::default()?;

// Validate a WASM component
let report = client.validate_component(Path::new("component.wasm"))?;

if report.is_valid {
    println!("Component is valid!");
} else {
    println!("Errors: {:?}", report.errors);
}
```

### Runtime Execution (Requires `runtime` Feature)

```rust
use portalis_wassette_bridge::{WassetteClient, WassetteConfig, ComponentPermissions};

// Configure with custom permissions
let mut config = WassetteConfig::default();
config.permissions.allow_fs = true;
config.permissions.allowed_paths = vec!["/tmp".to_string()];

let client = WassetteClient::new(config)?;

// Load a component
let handle = client.load_component(Path::new("component.wasm"))?;

// Execute with arguments
let result = client.execute_component(&handle, vec!["arg1".to_string()])?;

if result.success {
    println!("Output: {:?}", result.output);
} else {
    println!("Error: {:?}", result.error);
}
```

### Configuration Options

```rust
use portalis_wassette_bridge::{WassetteConfig, ComponentPermissions};

let config = WassetteConfig {
    enable_sandbox: true,           // Enable WASM sandboxing
    max_memory_mb: 128,             // Maximum memory per component
    max_execution_time_secs: 30,    // Execution timeout
    permissions: ComponentPermissions {
        allow_fs: false,            // Filesystem access
        allow_network: false,       // Network access
        allow_env: false,           // Environment variable access
        allowed_paths: vec![],      // Whitelisted filesystem paths
        allowed_hosts: vec![],      // Whitelisted network hosts
        allowed_env_vars: vec![],   // Whitelisted environment variables
    },
};
```

## Security

The wassette-bridge follows a **security-by-default** approach:

- **Sandboxing enabled** by default
- **All permissions denied** by default
- **Explicit allowlisting** required for filesystem, network, and environment access
- **Resource limits** enforced (memory, execution time)

### Permission Levels

1. **Restrictive (Default)**: All capabilities denied
2. **Testing**: Limited filesystem access (`/tmp` only), no network
3. **Production**: Configured per deployment requirements

## Integration with Portalis

The wassette-bridge integrates with several Portalis agents:

### Transpiler Agent

```rust
// In portalis-transpiler
use portalis_wassette_bridge::WassetteClient;

let client = WassetteClient::default()?;
let report = client.validate_component(Path::new(&wasm_output))?;

if !report.is_valid {
    return Err(anyhow!("Generated WASM is invalid: {:?}", report.errors));
}
```

### Build Agent

```rust
// Validate compiled WASM before packaging
let client = WassetteClient::default()?;
let report = client.validate_component(&wasm_path)?;
```

### Test Agent

```rust
// Execute WASM tests in isolated sandbox
let mut config = WassetteConfig::default();
config.permissions.allow_fs = true;
config.permissions.allowed_paths = vec![test_dir.to_string()];

let client = WassetteClient::new(config)?;
```

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                  Portalis Platform                       │
│  ┌────────────────────────────────────────────────────┐ │
│  │         Transpiler / Build / Test Agents           │ │
│  └────────────────────────────────────────────────────┘ │
│                           ↓                              │
│  ┌────────────────────────────────────────────────────┐ │
│  │            portalis-wassette-bridge                │ │
│  │  ┌──────────────────────────────────────────────┐ │ │
│  │  │  WassetteClient API                          │ │ │
│  │  │  - validate_component()                      │ │ │
│  │  │  - load_component()                          │ │ │
│  │  │  - execute_component()                       │ │ │
│  │  └──────────────────────────────────────────────┘ │ │
│  └────────────────────────────────────────────────────┘ │
│                           ↓                              │
│  ┌────────────────────────────────────────────────────┐ │
│  │         Wasmtime Runtime (optional)                │ │
│  │  - Component Model Support                         │ │
│  │  - WASI Implementation                             │ │
│  │  - Security Sandboxing                             │ │
│  └────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

## Testing

Run tests:

```bash
# Unit tests (no runtime required)
cargo test -p portalis-wassette-bridge

# Integration tests with runtime
cargo test -p portalis-wassette-bridge --features runtime

# All tests
cargo test -p portalis-wassette-bridge --all-features
```

## Development

### Building

```bash
# Build without runtime
cargo build -p portalis-wassette-bridge

# Build with runtime support
cargo build -p portalis-wassette-bridge --features runtime
```

### Adding New Features

1. Add functionality to `src/lib.rs`
2. If runtime-specific, add to `src/runtime.rs` with `#[cfg(feature = "runtime")]`
3. Add tests to `tests/integration_test.rs`
4. Update documentation

## Roadmap

- [ ] Full Wasmtime component instantiation
- [ ] Component interface introspection
- [ ] Advanced permission policies
- [ ] Performance benchmarking
- [ ] MCP integration for debugging
- [ ] OCI registry component loading

## Related Projects

- [Wassette](https://github.com/microsoft/wassette) - Security-oriented WASM runtime
- [Wasmtime](https://wasmtime.dev/) - WebAssembly runtime engine
- [Portalis](https://github.com/portalis/portalis) - Python to Rust/WASM transpiler

## License

MIT - See LICENSE file for details.

## Contributing

Contributions welcome! Please follow the existing code style and include tests for new functionality.
