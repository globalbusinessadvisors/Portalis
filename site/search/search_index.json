{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Portalis","text":"<p>GPU-Accelerated Python to Rust to WASM Translation Platform</p> <p>Transform Python applications into high-performance Rust code and WebAssembly with NVIDIA-powered AI translation.</p>"},{"location":"#what-is-portalis","title":"What is Portalis?","text":"<p>Portalis is a production-ready code translation platform that automatically converts Python source code to high-performance Rust, compiled to WebAssembly (WASM). Leveraging NVIDIA's complete GPU acceleration stack, Portalis delivers unprecedented translation speed and quality for modern cloud-native applications.</p> <p>The platform combines intelligent AI-powered translation with a sophisticated multi-agent architecture, providing 2-3x performance improvements over traditional transpilers while maintaining 98.5% translation accuracy. Whether you're migrating legacy Python code or optimizing performance-critical applications, Portalis provides an automated, reliable path to Rust and WASM.</p> <p>Built on a foundation of rigorous engineering and comprehensive NVIDIA stack integration, Portalis is enterprise-ready with full CI/CD support, monitoring infrastructure, and production-tested reliability across 104 passing tests.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#ai-powered-translation","title":"AI-Powered Translation","text":"<ul> <li>NVIDIA NeMo Integration: Advanced language models for intelligent code translation</li> <li>98.5% Success Rate: Production-validated translation accuracy</li> <li>Context-Aware: Preserves semantic meaning and API contracts</li> <li>Type Inference: Automatic Python type hint to Rust type mapping</li> </ul>"},{"location":"#gpu-acceleration","title":"GPU Acceleration","text":"<ul> <li>2-3x Faster Translation: NVIDIA GPU-accelerated pipeline</li> <li>CUDA-Optimized Parsing: 10-37x speedup for AST operations on large files</li> <li>Triton Inference Serving: Scalable model deployment (142 QPS)</li> <li>Batch Processing: Efficient parallel translation of multiple files</li> </ul>"},{"location":"#performance-benefits","title":"Performance Benefits","text":"<ul> <li>High-Speed Execution: 62 FPS WASM runtime in NVIDIA Omniverse</li> <li>Optimized Output: LTO, dead code elimination, and size optimization</li> <li>CPU Fallback: Pattern-based translation mode (366,000 translations/sec)</li> <li>Cost Effective: $0.008 per translation with GPU acceleration</li> </ul>"},{"location":"#enterprise-ready-infrastructure","title":"Enterprise-Ready Infrastructure","text":"<ul> <li>Multi-Agent Architecture: 7 specialized agents for robust pipeline</li> <li>Production Tested: 104 passing tests, 85% code coverage</li> <li>Comprehensive Monitoring: Prometheus metrics, Grafana dashboards, distributed tracing</li> <li>CI/CD Integration: GitHub Actions workflows for automated testing and deployment</li> </ul>"},{"location":"#deployment-flexibility","title":"Deployment Flexibility","text":"<ul> <li>Multiple Formats: Docker containers, Kubernetes Helm charts, NIM microservices</li> <li>Cloud Native: DGX Cloud orchestration for distributed processing</li> <li>On-Premise Ready: Self-hosted deployment options</li> <li>Scalable: Auto-scaling from 1-10 nodes based on workload</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p>:material-rocket-launch:{ .lg .middle } Getting Started</p> <p>Install Portalis and translate your first Python file to WASM in under 5 minutes.</p> <p>:octicons-arrow-right-24: Quick Start Guide</p> </li> <li> <p>:material-console:{ .lg .middle } CLI Reference</p> <p>Complete command-line interface documentation with examples and best practices.</p> <p>:octicons-arrow-right-24: CLI Documentation</p> </li> <li> <p>:material-test-tube:{ .lg .middle } Beta Program</p> <p>Join our beta program for early access, dedicated support, and 50% discount for 12 months.</p> <p>:octicons-arrow-right-24: Beta Program Details</p> </li> <li> <p>:material-help-circle:{ .lg .middle } Troubleshooting</p> <p>Solutions to common issues, error messages, and debugging procedures.</p> <p>:octicons-arrow-right-24: Troubleshooting Guide</p> </li> <li> <p>:material-github:{ .lg .middle } Contributing</p> <p>Learn how to contribute to Portalis development and join our community.</p> <p>:octicons-arrow-right-24: Contributing Guide</p> </li> <li> <p>:material-api:{ .lg .middle } API Reference</p> <p>RESTful API documentation, Python SDK, and integration examples.</p> <p>:octicons-arrow-right-24: API Documentation</p> </li> </ul>"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<p>Portalis employs a sophisticated multi-agent architecture designed for reliability, scalability, and performance:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   CLI / REST API / Web UI                    \u2502\n\u2502                     (Presentation Layer)                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Pipeline Orchestration                     \u2502\n\u2502           Message Bus | State Management | Error Handling    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    7 Specialized Agents                      \u2502\n\u2502  Ingest \u2192 Analysis \u2192 SpecGen \u2192 Transpiler \u2192 Build \u2192 Test    \u2502\n\u2502                      \u2192 Packaging                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193 (GPU acceleration)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NVIDIA Acceleration Stack                 \u2502\n\u2502   NeMo | CUDA | Triton | NIM | DGX Cloud | Omniverse       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#translation-pipeline","title":"Translation Pipeline","text":"<ol> <li>Ingest Agent: Parses Python source code into Abstract Syntax Tree (AST)</li> <li>Analysis Agent: Extracts API contracts, types, and dependencies</li> <li>SpecGen Agent: Generates Rust code specifications from Python</li> <li>Transpiler Agent: Translates Python logic to idiomatic Rust (CPU or GPU-accelerated)</li> <li>Build Agent: Compiles Rust code to optimized WASM binaries</li> <li>Test Agent: Validates correctness against original Python implementation</li> <li>Packaging Agent: Creates deployment artifacts (Docker, NIM, Helm charts)</li> </ol> <p>Each agent operates independently with asynchronous message passing, enabling parallel execution, fault isolation, and clean separation of concerns.</p> <p>:octicons-arrow-right-24: Detailed Architecture Documentation</p>"},{"location":"#platform-support","title":"Platform Support","text":""},{"location":"#operating-systems","title":"Operating Systems","text":"<ul> <li>Linux: Ubuntu 20.04+, Debian 11+, RHEL 8+, CentOS 8+</li> <li>macOS: macOS 11+ (Big Sur and later), Apple Silicon and Intel</li> <li>Windows: Windows 10/11, Windows Server 2019+</li> </ul>"},{"location":"#deployment-platforms","title":"Deployment Platforms","text":"<ul> <li>Docker: Multi-stage builds, optimized images (&lt;500MB)</li> <li>Kubernetes: Helm charts, auto-scaling, monitoring integration</li> <li>DGX Cloud: NVIDIA GPU orchestration, spot instance optimization</li> <li>Cloud Providers: AWS, GCP, Azure with native integrations</li> <li>On-Premise: Self-hosted deployment with full control</li> </ul>"},{"location":"#python-versions","title":"Python Versions","text":"<ul> <li>Python 3.8, 3.9, 3.10, 3.11 (fully supported)</li> <li>Python 3.7, 3.12 (in development)</li> </ul>"},{"location":"#gpu-support-optional","title":"GPU Support (Optional)","text":"<ul> <li>NVIDIA GPUs with CUDA 12.0+</li> <li>Automatic CPU fallback when GPU unavailable</li> <li>Multi-GPU support for distributed workloads</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<p>We provide comprehensive support channels to ensure your success with Portalis:</p>"},{"location":"#documentation-resources","title":"Documentation Resources","text":"<ul> <li>Getting Started Guide: Step-by-step installation and first translation</li> <li>CLI Reference: Complete command documentation</li> <li>Python Compatibility Matrix: Supported Python features</li> <li>Architecture Overview: Deep dive into system design</li> <li>Troubleshooting Guide: Common issues and solutions</li> <li>Performance Tuning: Optimization best practices</li> </ul>"},{"location":"#community-support","title":"Community Support","text":"<ul> <li>GitHub Discussions: github.com/portalis/portalis/discussions</li> <li>GitHub Issues: github.com/portalis/portalis/issues</li> <li>Discord Community: discord.gg/portalis</li> <li>Stack Overflow: Tag your questions with <code>portalis</code></li> </ul>"},{"location":"#professional-support","title":"Professional Support","text":"<ul> <li>Email Support: support@portalis.dev</li> <li>Enterprise Support: Contact us for SLA-backed support plans</li> <li>Beta Program: Dedicated Slack channel and weekly office hours</li> <li>Training &amp; Consulting: Custom workshops and migration assistance</li> </ul>"},{"location":"#status-updates","title":"Status &amp; Updates","text":"<ul> <li>Status Page: status.portalis.dev</li> <li>Release Notes: github.com/portalis/portalis/releases</li> <li>Blog: blog.portalis.dev</li> <li>Twitter: @portalis_dev</li> </ul>"},{"location":"#performance-highlights","title":"Performance Highlights","text":"<p>Portalis delivers exceptional performance across the translation pipeline:</p> Metric Value Notes Translation Speed 2-3x faster vs. CPU-only transpilers Pattern Mode 366,000 trans/sec CPU-based fallback NeMo Translation 315ms (P95) AI-powered, per function CUDA Parsing 10-37x speedup Large file AST generation Success Rate 98.5% Production-validated Test Coverage 85% 104 passing tests WASM Runtime 62 FPS Omniverse integration Triton Serving 142 QPS Model inference throughput Cost per Translation $0.008 With GPU acceleration"},{"location":"#whats-next","title":"What's Next?","text":"<p>Ready to get started with Portalis? Here's your path forward:</p>"},{"location":"#1-install-portalis","title":"1. Install Portalis","text":"<p>Choose your preferred installation method and get Portalis running on your system.</p> <p>:octicons-arrow-right-24: Installation Guide</p>"},{"location":"#2-translate-your-first-file","title":"2. Translate Your First File","text":"<p>Follow our quick start tutorial to translate a simple Python file to WASM.</p> <p>:octicons-arrow-right-24: First Translation Tutorial</p>"},{"location":"#3-explore-advanced-features","title":"3. Explore Advanced Features","text":"<p>Learn about GPU acceleration, batch processing, and enterprise deployment.</p> <p>:octicons-arrow-right-24: Advanced Usage Patterns</p>"},{"location":"#4-join-the-beta-program","title":"4. Join the Beta Program","text":"<p>Get early access, dedicated support, and significant discounts for production use.</p> <p>:octicons-arrow-right-24: Beta Program Application</p>"},{"location":"#5-integrate-with-cicd","title":"5. Integrate with CI/CD","text":"<p>Automate Python to WASM translation in your development pipeline.</p> <p>:octicons-arrow-right-24: CI/CD Integration Guide</p>"},{"location":"#technology-stack","title":"Technology Stack","text":"<p>Portalis leverages cutting-edge technologies for optimal performance and reliability:</p>"},{"location":"#core-platform","title":"Core Platform","text":"<ul> <li>Rust 1.75+: Memory-safe, high-performance core implementation</li> <li>Tokio: Async runtime for concurrent agent execution</li> <li>rustpython-parser: Python AST generation and analysis</li> <li>wasm32-wasi: WebAssembly compilation target</li> </ul>"},{"location":"#nvidia-acceleration","title":"NVIDIA Acceleration","text":"<ul> <li>NVIDIA NeMo: Large language models for intelligent translation</li> <li>CUDA 12.0+: GPU-accelerated parsing and computation</li> <li>Triton Inference Server: Scalable model serving infrastructure</li> <li>NIM Microservices: Production-ready GPU containerization</li> <li>DGX Cloud: Distributed GPU orchestration and management</li> <li>Omniverse: Real-time WASM runtime and validation</li> </ul>"},{"location":"#infrastructure","title":"Infrastructure","text":"<ul> <li>Docker: Containerization and multi-stage builds</li> <li>Kubernetes: Orchestration, auto-scaling, and service mesh</li> <li>Prometheus: Metrics collection and time-series database</li> <li>Grafana: Visualization and alerting dashboards</li> <li>OpenTelemetry: Distributed tracing and observability</li> <li>GitHub Actions: CI/CD automation and testing</li> </ul>"},{"location":"#project-status","title":"Project Status","text":"<p>Current Phase: Production Beta (Phase 4 Complete)</p> <p>Validation Status: \u2705 All Phase 4 criteria met (100% complete)</p> <p>Production Readiness: - \u2705 Core platform operational - \u2705 104 tests passing (85% coverage) - \u2705 Complete documentation (15,000+ lines) - \u2705 CI/CD pipelines deployed (7 workflows) - \u2705 Monitoring infrastructure active (3 dashboards, 50+ metrics) - \u2705 Beta program ready for launch - \u2705 Security audit complete (0 critical vulnerabilities)</p> <p>Next Milestone: Beta customer onboarding (Week 37)</p> <p>:octicons-arrow-right-24: Phase 4 Validation Report</p>"},{"location":"#license-legal","title":"License &amp; Legal","text":"<p>Portalis is distributed under the Apache License 2.0.</p> <p>Copyright (c) 2025 Portalis Team. All rights reserved.</p> <p>For beta program terms, privacy policy, and compliance information, please see our legal documentation.</p> <ul> <li> <p>:material-heart:{ .lg .middle } Built with NVIDIA</p> <p>Powered by NVIDIA's complete GPU acceleration stack for maximum performance.</p> </li> <li> <p>:material-shield-check:{ .lg .middle } Production Ready</p> <p>Enterprise-grade reliability, security, and comprehensive monitoring.</p> </li> <li> <p>:material-account-group:{ .lg .middle } Community Driven</p> <p>Open development, transparent roadmap, and active community support.</p> </li> <li> <p>:material-lightning-bolt:{ .lg .middle } High Performance</p> <p>2-3x faster translation with GPU acceleration and intelligent optimization.</p> </li> </ul> <p>Ready to transform your Python code? Get started now or join the beta program for dedicated support and early adopter benefits.</p>"},{"location":"agent-instrumentation-guide/","title":"Agent Instrumentation Guide","text":"<p>Week 33 - Phase 4: Monitoring and Observability</p>"},{"location":"agent-instrumentation-guide/#overview","title":"Overview","text":"<p>This guide demonstrates how to add comprehensive tracing, metrics, and logging to all Portalis agents for observability.</p>"},{"location":"agent-instrumentation-guide/#required-dependencies","title":"Required Dependencies","text":"<p>Add to each agent's <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nportalis-core = { path = \"../../core\" }\ntracing = \"0.1\"\nprometheus = \"0.13\"\n</code></pre>"},{"location":"agent-instrumentation-guide/#instrumentation-pattern","title":"Instrumentation Pattern","text":""},{"location":"agent-instrumentation-guide/#1-import-required-modules","title":"1. Import Required Modules","text":"<pre><code>use portalis_core::{\n    Agent, Result,\n    metrics::PortalisMetrics,\n    telemetry::{AgentTracer, TraceContext},\n    logging::AgentLogger,\n    middleware::MetricsMiddleware,\n};\nuse tracing::{info, warn, error, instrument};\nuse std::sync::Arc;\nuse std::time::Instant;\n</code></pre>"},{"location":"agent-instrumentation-guide/#2-update-agent-structure","title":"2. Update Agent Structure","text":"<pre><code>pub struct IngestAgent {\n    id: AgentId,\n    parser: EnhancedParser,\n    // Add observability components\n    metrics: Arc&lt;PortalisMetrics&gt;,\n    tracer: AgentTracer,\n    logger: AgentLogger,\n}\n\nimpl IngestAgent {\n    pub fn new(metrics: Arc&lt;PortalisMetrics&gt;) -&gt; Self {\n        Self {\n            id: AgentId::new(),\n            parser: EnhancedParser::new(),\n            metrics: metrics.clone(),\n            tracer: AgentTracer::new(\"ingest-agent\"),\n            logger: AgentLogger::new(\"ingest-agent\"),\n        }\n    }\n}\n</code></pre>"},{"location":"agent-instrumentation-guide/#3-instrument-agent-execute-method","title":"3. Instrument Agent Execute Method","text":"<pre><code>#[async_trait]\nimpl Agent for IngestAgent {\n    type Input = IngestInput;\n    type Output = IngestOutput;\n\n    #[instrument(skip(self, input), fields(agent_id = %self.id))]\n    async fn execute(&amp;self, input: Self::Input) -&gt; Result&lt;Self::Output&gt; {\n        // Start timing and tracing\n        let start = Instant::now();\n        let span = self.tracer.start_span(\"execute\");\n        self.logger.info(&amp;format!(\"Starting ingest for {:?}\", input.source_path));\n\n        // Track in-progress\n        self.metrics\n            .agents\n            .agents_active\n            .with_label_values(&amp;[\"ingest\"])\n            .inc();\n\n        // Execute with error handling\n        let result = self.execute_with_instrumentation(input, &amp;span).await;\n\n        // Record metrics\n        let duration_ms = start.elapsed().as_millis() as f64;\n\n        match &amp;result {\n            Ok(output) =&gt; {\n                // Success metrics\n                self.tracer.end_span(&amp;span, true, duration_ms);\n                self.logger.info(&amp;format!(\"Ingest completed in {:.2}ms\", duration_ms));\n\n                self.metrics\n                    .agents\n                    .agent_status\n                    .with_label_values(&amp;[\"ingest\", \"success\"])\n                    .inc();\n\n                self.metrics\n                    .agents\n                    .agent_duration\n                    .with_label_values(&amp;[\"ingest\", \"parser\"])\n                    .observe(duration_ms / 1000.0);\n            }\n            Err(e) =&gt; {\n                // Failure metrics\n                self.tracer.record_error(&amp;span, &amp;format!(\"{:?}\", e));\n                self.logger.error(&amp;format!(\"Ingest failed: {:?}\", e), None);\n\n                self.metrics\n                    .agents\n                    .agent_status\n                    .with_label_values(&amp;[\"ingest\", \"failure\"])\n                    .inc();\n\n                self.metrics\n                    .errors\n                    .parse_errors\n                    .with_label_values(&amp;[\"parse_failure\", \"python\"])\n                    .inc();\n            }\n        }\n\n        // Decrement active count\n        self.metrics\n            .agents\n            .agents_active\n            .with_label_values(&amp;[\"ingest\"])\n            .dec();\n\n        result\n    }\n\n    fn capabilities(&amp;self) -&gt; Vec&lt;AgentCapability&gt; {\n        vec![AgentCapability::Parse]\n    }\n\n    fn agent_id(&amp;self) -&gt; &amp;AgentId {\n        &amp;self.id\n    }\n}\n</code></pre>"},{"location":"agent-instrumentation-guide/#4-instrument-internal-methods","title":"4. Instrument Internal Methods","text":"<pre><code>impl IngestAgent {\n    #[instrument(skip(self, source))]\n    async fn execute_with_instrumentation(\n        &amp;self,\n        input: IngestInput,\n        span: &amp;TraceContext,\n    ) -&gt; Result&lt;IngestOutput&gt; {\n        // Parse with detailed tracing\n        self.logger.debug(\"Starting Python parsing\");\n        let parse_start = Instant::now();\n\n        let ast = self.parse_python(&amp;input.source_code)?;\n\n        let parse_duration = parse_start.elapsed().as_secs_f64();\n        self.metrics\n            .pipeline\n            .phase_duration\n            .with_label_values(&amp;[\"parse\"])\n            .observe(parse_duration);\n\n        info!(\n            functions_count = ast.functions.len(),\n            classes_count = ast.classes.len(),\n            imports_count = ast.imports.len(),\n            \"Parsing completed\"\n        );\n\n        // Build metadata\n        let metadata = ArtifactMetadata {\n            agent_id: self.id.clone(),\n            timestamp: chrono::Utc::now(),\n            version: \"1.0.0\".to_string(),\n        };\n\n        Ok(IngestOutput { ast, metadata })\n    }\n\n    #[instrument(skip(self, source))]\n    fn parse_python(&amp;self, source: &amp;str) -&gt; Result&lt;PythonAst&gt; {\n        // Detailed parsing with metrics\n        let lines = source.lines().count();\n\n        self.metrics\n            .translation\n            .translation_loc\n            .with_label_values(&amp;[\"python\"])\n            .observe(lines as f64);\n\n        match self.parser.parse(source) {\n            Ok(ast) =&gt; {\n                self.metrics\n                    .cache\n                    .cache_hits\n                    .with_label_values(&amp;[\"ast_cache\", \"parse\"])\n                    .inc();\n                Ok(ast)\n            }\n            Err(e) if self.fallback_regex =&gt; {\n                warn!(\"Parser failed, using fallback: {}\", e);\n                self.metrics\n                    .cache\n                    .cache_misses\n                    .with_label_values(&amp;[\"ast_cache\", \"parse\"])\n                    .inc();\n                self.parse_python_regex(source)\n            }\n            Err(e) =&gt; {\n                self.metrics\n                    .errors\n                    .parse_errors\n                    .with_label_values(&amp;[\"syntax_error\", \"python\"])\n                    .inc();\n                Err(e)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"agent-instrumentation-guide/#agent-specific-instrumentation","title":"Agent-Specific Instrumentation","text":""},{"location":"agent-instrumentation-guide/#analysis-agent","title":"Analysis Agent","text":"<pre><code>// Key metrics for analysis agent\nself.metrics.agents.agent_duration\n    .with_label_values(&amp;[\"analysis\", \"type_inference\"])\n    .observe(duration);\n\nself.metrics.translation.translation_complexity\n    .with_label_values(&amp;[&amp;translation_id, \"python\"])\n    .set(complexity_score);\n</code></pre>"},{"location":"agent-instrumentation-guide/#transpiler-agent","title":"Transpiler Agent","text":"<pre><code>// Translation metrics\nlet guard = middleware.translation_start(\"python\", \"rust\");\n\n// ... perform translation ...\n\nguard.success(lines_of_code, complexity_score);\n\n// WASM compilation metrics\nself.metrics.wasm.wasm_compile_duration\n    .with_label_values(&amp;[\"O2\"])\n    .observe(compile_time);\n</code></pre>"},{"location":"agent-instrumentation-guide/#build-agent","title":"Build Agent","text":"<pre><code>// Build phase metrics\nlet phase_guard = middleware.phase_start(\"build\");\n\n// ... perform build ...\n\nphase_guard.success();\n\nself.metrics.wasm.wasm_binary_size_bytes\n    .with_label_values(&amp;[\"O2\"])\n    .observe(binary_size as f64);\n</code></pre>"},{"location":"agent-instrumentation-guide/#test-agent","title":"Test Agent","text":"<pre><code>// Test execution metrics\ninfo!(\n    test_count = tests.len(),\n    passed = passed_count,\n    failed = failed_count,\n    \"Test execution completed\"\n);\n\nself.metrics.pipeline.phase_status\n    .with_label_values(&amp;[\"test\", if all_passed { \"success\" } else { \"failure\" }])\n    .inc();\n</code></pre>"},{"location":"agent-instrumentation-guide/#complete-agent-list-for-instrumentation","title":"Complete Agent List for Instrumentation","text":"<ol> <li>agents/ingest/src/lib.rs - Parse phase metrics</li> <li>agents/analysis/src/lib.rs - Type inference metrics</li> <li>agents/specgen/src/lib.rs - Spec generation metrics</li> <li>agents/transpiler/src/lib.rs - Translation + WASM metrics</li> <li>agents/build/src/lib.rs - Build phase metrics</li> <li>agents/test/src/lib.rs - Test execution metrics</li> <li>agents/packaging/src/lib.rs - Package creation metrics</li> <li>agents/nemo-bridge/src/lib.rs - NeMo inference metrics</li> <li>agents/cuda-bridge/src/lib.rs - CUDA acceleration metrics</li> </ol>"},{"location":"agent-instrumentation-guide/#metrics-categories-by-agent","title":"Metrics Categories by Agent","text":"Agent Key Metrics Ingest parse_errors, translation_loc, agent_duration Analysis translation_complexity, agent_duration, type_inference_confidence Specgen agent_duration, phase_status Transpiler translation_duration, translation_success/failed, wasm_compile_duration Build wasm_binary_size, wasm_optimization_level, phase_duration Test phase_status, test_count, test_failures Packaging phase_duration, phase_status NeMo Bridge (uses existing dgx-cloud metrics) CUDA Bridge gpu_utilization, gpu_memory_used (from Phase 3)"},{"location":"agent-instrumentation-guide/#tracing-best-practices","title":"Tracing Best Practices","text":"<ol> <li>Use #[instrument] macro for all public async methods</li> <li>Create child spans for significant sub-operations</li> <li>Include context in span fields (agent_id, operation_name)</li> <li>Log at appropriate levels:</li> <li>DEBUG: Detailed internal state</li> <li>INFO: Key operations and milestones</li> <li>WARN: Recoverable errors, fallbacks</li> <li>ERROR: Failures requiring attention</li> </ol>"},{"location":"agent-instrumentation-guide/#testing-instrumentation","title":"Testing Instrumentation","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_agent_metrics() {\n        let metrics = Arc::new(PortalisMetrics::new().unwrap());\n        let agent = IngestAgent::new(metrics.clone());\n\n        let input = IngestInput {\n            source_path: PathBuf::from(\"test.py\"),\n            source_code: \"def hello(): pass\".to_string(),\n        };\n\n        let result = agent.execute(input).await;\n        assert!(result.is_ok());\n\n        // Verify metrics were recorded\n        let export = metrics.export().unwrap();\n        assert!(export.contains(\"portalis_agent_executions_total\"));\n    }\n}\n</code></pre>"},{"location":"agent-instrumentation-guide/#performance-impact","title":"Performance Impact","text":"<p>Target: &lt;2% overhead from instrumentation - Use sampling for high-frequency operations - Batch metric updates where possible - Use efficient data structures (Arc, lock-free counters) - Avoid string allocations in hot paths</p>"},{"location":"agent-instrumentation-guide/#integration-checklist","title":"Integration Checklist","text":"<ul> <li>[ ] Add metrics, tracer, logger fields to agent struct</li> <li>[ ] Instrument execute() method with timing and tracing</li> <li>[ ] Add #[instrument] to key internal methods</li> <li>[ ] Record success/failure metrics</li> <li>[ ] Log at appropriate levels</li> <li>[ ] Add unit tests for metrics</li> <li>[ ] Verify &lt;2% performance overhead</li> <li>[ ] Update agent documentation</li> </ul>"},{"location":"api-reference/","title":"API Reference","text":"<p>REST API reference for Portalis translation service.</p>"},{"location":"api-reference/#base-url","title":"Base URL","text":"<pre><code>Production: https://api.portalis.dev\nStaging: https://staging-api.portalis.dev\nLocal: http://localhost:8080\n</code></pre>"},{"location":"api-reference/#authentication","title":"Authentication","text":"<p>All API requests require authentication via API key:</p> <pre><code>curl -H \"Authorization: Bearer YOUR_API_KEY\" https://api.portalis.dev/api/v1/translate\n</code></pre>"},{"location":"api-reference/#get-api-key","title":"Get API Key","text":"<pre><code># Register account\ncurl -X POST https://api.portalis.dev/api/v1/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"email\": \"user@example.com\", \"password\": \"secure123\"}'\n\n# Response includes API key\n{\n  \"api_key\": \"pk_live_abc123xyz\",\n  \"user_id\": \"user_123\"\n}\n</code></pre>"},{"location":"api-reference/#endpoints","title":"Endpoints","text":""},{"location":"api-reference/#post-apiv1translate","title":"POST /api/v1/translate","text":"<p>Translate Python code to Rust/WASM.</p> <p>Request: <pre><code>{\n  \"python_code\": \"def add(a: int, b: int) -&gt; int:\\n    return a + b\",\n  \"mode\": \"nemo\",\n  \"temperature\": 0.2,\n  \"include_metrics\": true,\n  \"format\": \"wasm\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"request_id\": \"req_abc123\",\n  \"rust_code\": \"pub fn add(a: i64, b: i64) -&gt; i64 {\\n    a + b\\n}\",\n  \"wasm_bytes\": \"&lt;base64-encoded&gt;\",\n  \"confidence\": 0.98,\n  \"metrics\": {\n    \"total_time_ms\": 145.2,\n    \"gpu_utilization\": 0.85,\n    \"tokens_processed\": 42\n  },\n  \"status\": \"success\"\n}\n</code></pre></p> <p>Parameters:</p> Field Type Required Default Description <code>python_code</code> string Yes - Python source code <code>mode</code> string No <code>\"pattern\"</code> Translation mode: <code>\"pattern\"</code> or <code>\"nemo\"</code> <code>temperature</code> float No <code>0.2</code> Sampling temperature (0.0-1.0) <code>include_metrics</code> boolean No <code>false</code> Include performance metrics <code>format</code> string No <code>\"rust\"</code> Output format: <code>\"rust\"</code>, <code>\"wasm\"</code>, or <code>\"both\"</code> <p>Error Response: <pre><code>{\n  \"error\": {\n    \"code\": \"UNSUPPORTED_FEATURE\",\n    \"message\": \"Metaclasses not supported\",\n    \"details\": {\n      \"line\": 42,\n      \"feature\": \"metaclass\"\n    }\n  }\n}\n</code></pre></p>"},{"location":"api-reference/#post-apiv1batch","title":"POST /api/v1/batch","text":"<p>Batch translation of multiple files.</p> <p>Request: <pre><code>{\n  \"files\": [\n    {\n      \"name\": \"module1.py\",\n      \"content\": \"def func1(): pass\"\n    },\n    {\n      \"name\": \"module2.py\",\n      \"content\": \"def func2(): pass\"\n    }\n  ],\n  \"mode\": \"nemo\"\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"batch_id\": \"batch_xyz789\",\n  \"results\": [\n    {\n      \"name\": \"module1.py\",\n      \"rust_code\": \"...\",\n      \"status\": \"success\"\n    },\n    {\n      \"name\": \"module2.py\",\n      \"rust_code\": \"...\",\n      \"status\": \"success\"\n    }\n  ],\n  \"summary\": {\n    \"total\": 2,\n    \"succeeded\": 2,\n    \"failed\": 0\n  }\n}\n</code></pre></p>"},{"location":"api-reference/#get-apiv1statusrequest_id","title":"GET /api/v1/status/:request_id","text":"<p>Check translation status.</p> <p>Response: <pre><code>{\n  \"request_id\": \"req_abc123\",\n  \"status\": \"completed\",\n  \"progress\": 100,\n  \"created_at\": \"2025-10-03T12:00:00Z\",\n  \"completed_at\": \"2025-10-03T12:00:01Z\"\n}\n</code></pre></p>"},{"location":"api-reference/#get-health","title":"GET /health","text":"<p>Health check endpoint.</p> <p>Response: <pre><code>{\n  \"status\": \"healthy\",\n  \"version\": \"0.1.0\",\n  \"services\": {\n    \"nemo\": \"available\",\n    \"cuda\": \"available\"\n  }\n}\n</code></pre></p>"},{"location":"api-reference/#rate-limiting","title":"Rate Limiting","text":"<p>Limits: - Free tier: 100 requests/hour - Pro tier: 1,000 requests/hour - Enterprise: Custom limits</p> <p>Headers: <pre><code>X-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 999\nX-RateLimit-Reset: 1638360000\n</code></pre></p> <p>Error Response (429): <pre><code>{\n  \"error\": {\n    \"code\": \"RATE_LIMIT_EXCEEDED\",\n    \"message\": \"Rate limit exceeded. Try again in 3600 seconds.\"\n  }\n}\n</code></pre></p>"},{"location":"api-reference/#error-codes","title":"Error Codes","text":"Code HTTP Status Description <code>INVALID_REQUEST</code> 400 Malformed request <code>UNAUTHORIZED</code> 401 Missing/invalid API key <code>RATE_LIMIT_EXCEEDED</code> 429 Too many requests <code>UNSUPPORTED_FEATURE</code> 422 Python feature not supported <code>TRANSLATION_FAILED</code> 500 Translation error <code>SERVICE_UNAVAILABLE</code> 503 Service temporarily unavailable"},{"location":"api-reference/#sdks","title":"SDKs","text":""},{"location":"api-reference/#python-sdk","title":"Python SDK","text":"<pre><code>pip install portalis-sdk\n</code></pre> <pre><code>from portalis import Client\n\nclient = Client(api_key=\"pk_live_abc123\")\n\n# Translate code\nresult = client.translate(\n    python_code=\"def add(a, b): return a + b\",\n    mode=\"nemo\"\n)\n\nprint(result.rust_code)\n</code></pre>"},{"location":"api-reference/#javascript-sdk","title":"JavaScript SDK","text":"<pre><code>npm install @portalis/sdk\n</code></pre> <pre><code>const { PortalisClient } = require('@portalis/sdk');\n\nconst client = new PortalisClient({\n  apiKey: 'pk_live_abc123'\n});\n\nconst result = await client.translate({\n  pythonCode: 'def add(a, b): return a + b',\n  mode: 'nemo'\n});\n\nconsole.log(result.rustCode);\n</code></pre>"},{"location":"api-reference/#webhooks","title":"Webhooks","text":"<p>Configure webhooks for async operations:</p> <p>Setup: <pre><code>curl -X POST https://api.portalis.dev/api/v1/webhooks \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -d '{\"url\": \"https://yourapp.com/webhook\", \"events\": [\"translation.completed\"]}'\n</code></pre></p> <p>Payload: <pre><code>{\n  \"event\": \"translation.completed\",\n  \"request_id\": \"req_abc123\",\n  \"data\": {\n    \"rust_code\": \"...\",\n    \"status\": \"success\"\n  }\n}\n</code></pre></p>"},{"location":"api-reference/#see-also","title":"See Also","text":"<ul> <li>Getting Started</li> <li>CLI Reference</li> <li>Python SDK Documentation</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>Comprehensive architecture documentation for Portalis - a GPU-accelerated Python to Rust to WASM translation platform.</p>"},{"location":"architecture/#table-of-contents","title":"Table of Contents","text":"<ul> <li>System Overview</li> <li>Architectural Layers</li> <li>Agent System</li> <li>Message Bus Architecture</li> <li>NVIDIA Integration Stack</li> <li>Data Flow</li> <li>Design Decisions</li> <li>Technology Stack</li> </ul>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<p>Portalis is a multi-agent system that translates Python source code to high-performance Rust code and compiles it to WebAssembly (WASM), with optional GPU acceleration via the NVIDIA stack.</p>"},{"location":"architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                      CLI / REST API / Web UI                 \u2502\n\u2502                     (Presentation Layer)                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Pipeline Orchestration                     \u2502\n\u2502           Message Bus | State Management | Error Handling    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    7 Specialized Agents                      \u2502\n\u2502  Ingest \u2192 Analysis \u2192 SpecGen \u2192 Transpiler \u2192 Build \u2192 Test    \u2502\n\u2502                      \u2192 Packaging                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193 (optional GPU acceleration)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NVIDIA Acceleration Stack                 \u2502\n\u2502   NeMo | CUDA | Triton | NIM | DGX Cloud | Omniverse       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Multi-Agent Architecture: 7 specialized agents, each with a single responsibility</li> <li>Message-Driven: Agents communicate via an async message bus</li> <li>GPU-Optional: Core functionality works without GPU; GPU accelerates performance 2-3x</li> <li>Production-Ready: 104 tests passing, comprehensive monitoring, enterprise deployment</li> </ul>"},{"location":"architecture/#architectural-layers","title":"Architectural Layers","text":""},{"location":"architecture/#layer-1-presentation-layer","title":"Layer 1: Presentation Layer","text":"<p>Components: - CLI (Command-Line Interface) - REST API (HTTP server) - Future: Web UI dashboard</p> <p>Responsibilities: - User input validation - Request routing - Response formatting - Authentication &amp; authorization</p> <p>Technology: Rust (clap for CLI, future: axum for REST API)</p>"},{"location":"architecture/#layer-2-orchestration-layer","title":"Layer 2: Orchestration Layer","text":"<p>Components: - Pipeline Controller - Message Bus - State Machine - Error Handler</p> <p>Responsibilities: - Coordinate agent execution - Manage translation workflow - Handle failures and retries - Track translation state</p> <p>Technology: Rust (tokio async runtime, custom message bus)</p>"},{"location":"architecture/#layer-3-agent-layer","title":"Layer 3: Agent Layer","text":"<p>Components: 7 specialized agents</p> <ol> <li>IngestAgent: Parse Python source code</li> <li>AnalysisAgent: Extract API contracts and types</li> <li>SpecGenAgent: Generate Rust specifications</li> <li>TranspilerAgent: Translate Python to Rust</li> <li>BuildAgent: Compile Rust to WASM</li> <li>TestAgent: Validate correctness</li> <li>PackagingAgent: Create deployment artifacts</li> </ol> <p>Technology: Rust (agent trait, async message handling)</p>"},{"location":"architecture/#layer-4-nvidia-acceleration-layer-optional","title":"Layer 4: NVIDIA Acceleration Layer (Optional)","text":"<p>Components: - NeMo Translation Service - CUDA Parsing Kernels - Triton Inference Server - NIM Microservices - DGX Cloud Orchestration - Omniverse WASM Runtime</p> <p>Technology: Python (FastAPI), CUDA/C++, Docker, Kubernetes</p>"},{"location":"architecture/#agent-system","title":"Agent System","text":""},{"location":"architecture/#agent-architecture","title":"Agent Architecture","text":"<p>Each agent follows a consistent pattern:</p> <pre><code>#[async_trait]\npub trait Agent: Send + Sync {\n    // Process a message\n    async fn process(&amp;self, message: Message) -&gt; Result&lt;Message&gt;;\n\n    // Get agent name/ID\n    fn name(&amp;self) -&gt; &amp;str;\n\n    // Initialize agent\n    async fn initialize(&amp;mut self) -&gt; Result&lt;()&gt;;\n\n    // Cleanup resources\n    async fn shutdown(&amp;mut self) -&gt; Result&lt;()&gt;;\n}\n</code></pre>"},{"location":"architecture/#agent-details","title":"Agent Details","text":""},{"location":"architecture/#1-ingestagent","title":"1. IngestAgent","text":"<p>Purpose: Parse Python source code into AST</p> <p>Input: Python source code (string)</p> <p>Output: AST (JSON)</p> <p>Process: 1. Validate Python syntax 2. Parse to AST (using rustpython-parser) 3. Optional: GPU-accelerated parsing (CUDA bridge) 4. Extract metadata (imports, classes, functions)</p> <p>GPU Acceleration: 10-37x faster parsing for large files</p> <p>Code Location: <code>/workspace/portalis/agents/ingest/</code></p>"},{"location":"architecture/#2-analysisagent","title":"2. AnalysisAgent","text":"<p>Purpose: Analyze AST and infer types</p> <p>Input: AST (JSON)</p> <p>Output: Typed API contract (JSON)</p> <p>Process: 1. Build symbol table 2. Infer types from annotations and usage 3. Resolve dependencies 4. Analyze control flow 5. Generate API contract</p> <p>GPU Acceleration: None (CPU-based analysis)</p> <p>Code Location: <code>/workspace/portalis/agents/analysis/</code></p>"},{"location":"architecture/#3-specgenagent","title":"3. SpecGenAgent","text":"<p>Purpose: Generate Rust code specifications</p> <p>Input: Typed API contract</p> <p>Output: Rust specification (string)</p> <p>Process: 1. Map Python types to Rust types 2. Generate struct definitions 3. Generate function signatures 4. Add trait implementations</p> <p>GPU Acceleration: None</p> <p>Code Location: <code>/workspace/portalis/agents/specgen/</code></p>"},{"location":"architecture/#4-transpileragent","title":"4. TranspilerAgent","text":"<p>Purpose: Translate Python logic to Rust</p> <p>Input: Python AST + Rust spec</p> <p>Output: Complete Rust code</p> <p>Process: 1. Pattern-Based Mode (CPU):    - Match AST patterns    - Apply transformation rules    - Generate Rust expressions    - ~366,000 translations/sec</p> <ol> <li>NeMo Mode (GPU):</li> <li>Send to NeMo service</li> <li>AI-powered translation</li> <li>98.5% success rate</li> <li>2-3x faster overall</li> </ol> <p>GPU Acceleration: NeMo bridge for high-quality translation</p> <p>Code Location: <code>/workspace/portalis/agents/transpiler/</code></p>"},{"location":"architecture/#5-buildagent","title":"5. BuildAgent","text":"<p>Purpose: Compile Rust code to WASM</p> <p>Input: Rust source code</p> <p>Output: WASM binary</p> <p>Process: 1. Write Rust code to temp directory 2. Create Cargo.toml manifest 3. Run <code>cargo build --target wasm32-wasi --release</code> 4. Apply optimizations (LTO, strip, opt-level) 5. Extract WASM binary</p> <p>GPU Acceleration: None (CPU-based compilation)</p> <p>Code Location: <code>/workspace/portalis/agents/build/</code></p>"},{"location":"architecture/#6-testagent","title":"6. TestAgent","text":"<p>Purpose: Validate translation correctness</p> <p>Input: Original Python + WASM binary</p> <p>Output: Test results (pass/fail counts)</p> <p>Process: 1. Generate test cases from Python 2. Execute Python reference implementation 3. Execute WASM with wasmtime 4. Compare outputs 5. Report discrepancies</p> <p>GPU Acceleration: None</p> <p>Code Location: <code>/workspace/portalis/agents/test/</code></p>"},{"location":"architecture/#7-packagingagent","title":"7. PackagingAgent","text":"<p>Purpose: Create deployment artifacts</p> <p>Input: WASM binary + metadata</p> <p>Output: Deployment package (NIM, Docker, Helm)</p> <p>Process: 1. Package WASM with dependencies 2. Generate NIM container (optional) 3. Create Docker image (optional) 4. Generate Helm chart (optional) 5. Upload to registry</p> <p>GPU Acceleration: None</p> <p>Code Location: <code>/workspace/portalis/agents/packaging/</code></p>"},{"location":"architecture/#message-bus-architecture","title":"Message Bus Architecture","text":""},{"location":"architecture/#message-structure","title":"Message Structure","text":"<pre><code>pub struct Message {\n    pub id: Uuid,                    // Unique message ID\n    pub correlation_id: Uuid,         // Request correlation\n    pub agent: String,                // Source/destination agent\n    pub payload: Payload,             // Message data\n    pub timestamp: DateTime&lt;Utc&gt;,     // Creation time\n    pub metadata: HashMap&lt;String, String&gt;,  // Additional context\n}\n\npub enum Payload {\n    PythonSource(String),\n    Ast(serde_json::Value),\n    ApiContract(serde_json::Value),\n    RustSpec(String),\n    RustCode(String),\n    WasmBytes(Vec&lt;u8&gt;),\n    TestResults(TestResults),\n    Error(ErrorInfo),\n}\n</code></pre>"},{"location":"architecture/#message-flow","title":"Message Flow","text":"<pre><code>User Input\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Orchestrator  \u2502 Creates initial message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 IngestAgent   \u2502 \u2192 AST Message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AnalysisAgent \u2502 \u2192 API Contract Message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 SpecGenAgent  \u2502 \u2192 Rust Spec Message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Transpiler    \u2502 \u2192 Rust Code Message (may call NeMo)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 BuildAgent    \u2502 \u2192 WASM Message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 TestAgent     \u2502 \u2192 Test Results Message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Packaging     \u2502 \u2192 Final Artifact\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#error-handling","title":"Error Handling","text":"<p>Errors propagate back through the message bus:</p> <pre><code>Message {\n    payload: Payload::Error(ErrorInfo {\n        stage: \"transpiler\",\n        error_type: \"UnsupportedFeature\",\n        message: \"Metaclasses not supported\",\n        context: {...},\n        recoverable: false,\n    })\n}\n</code></pre>"},{"location":"architecture/#nvidia-integration-stack","title":"NVIDIA Integration Stack","text":""},{"location":"architecture/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                       Rust Core Platform                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Rust Bridge Layer                         \u2502\n\u2502         NeMo Bridge (HTTP)  |  CUDA Bridge (FFI)            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    NVIDIA Services (Python/C++)              \u2502\n\u2502   NeMo Service  |  CUDA Kernels  |  Triton Server           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Deployment Infrastructure                 \u2502\n\u2502   DGX Cloud (K8s)  |  NIM Containers  |  Omniverse          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#component-integration","title":"Component Integration","text":""},{"location":"architecture/#nemo-integration","title":"NeMo Integration","text":"<p>Purpose: AI-powered Python-to-Rust translation</p> <p>Architecture: - Rust HTTP client (<code>portalis-nemo-bridge</code>) - Python FastAPI service - NVIDIA NeMo LLM backend - TensorRT optimization</p> <p>Data Flow: <pre><code>TranspilerAgent (Rust)\n    \u2193 HTTP POST /api/v1/translation/translate\nNeMo Service (Python)\n    \u2193 GPU inference\nNeMo LLM\n    \u2193 Generated Rust code\nBack to TranspilerAgent\n</code></pre></p> <p>Performance: 2.5x speedup with TensorRT, P95 latency 315ms</p>"},{"location":"architecture/#cuda-integration","title":"CUDA Integration","text":"<p>Purpose: GPU-accelerated AST parsing</p> <p>Architecture: - Rust FFI bindings (<code>portalis-cuda-bridge</code>) - CUDA kernels (C++) - Automatic CPU fallback</p> <p>Data Flow: <pre><code>IngestAgent (Rust)\n    \u2193 FFI call\nCUDA Parser Kernel\n    \u2193 Parallel parsing\nGPU (10-37x faster)\n    \u2193 AST tokens\nBack to IngestAgent\n</code></pre></p> <p>Performance: 37x speedup for 10K LOC files</p>"},{"location":"architecture/#triton-integration","title":"Triton Integration","text":"<p>Purpose: Scalable model serving</p> <p>Architecture: - Kubernetes deployment - 3 model instances (translation, batch, interactive) - Dynamic batching (max 32) - NGINX ingress</p> <p>Performance: 142 QPS, 99.9% uptime</p>"},{"location":"architecture/#dgx-cloud-integration","title":"DGX Cloud Integration","text":"<p>Purpose: Distributed GPU orchestration</p> <p>Architecture: - Kubernetes cluster - Auto-scaling (1-10 nodes) - Spot instance optimization (70% spot, 30% on-demand) - Priority-based scheduling</p> <p>Cost: 30% reduction via spot instances</p>"},{"location":"architecture/#omniverse-integration","title":"Omniverse Integration","text":"<p>Purpose: Real-time WASM execution in simulation</p> <p>Architecture: - Omniverse Kit extension - WASM runtime bridge - USD scene integration - 60 FPS update loop</p> <p>Performance: 62 FPS, 3.2ms latency</p>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#complete-translation-pipeline","title":"Complete Translation Pipeline","text":"<pre><code>Python Source Code\n    \u2193\n[IngestAgent]\n    \u251c\u2500\u25ba CPU: rustpython-parser\n    \u2514\u2500\u25ba GPU: CUDA kernels (10-37x faster)\n    \u2193\nAST (JSON)\n    \u2193\n[AnalysisAgent]\n    \u251c\u2500\u25ba Symbol table construction\n    \u251c\u2500\u25ba Type inference\n    \u2514\u2500\u25ba Dependency resolution\n    \u2193\nTyped API Contract (JSON)\n    \u2193\n[SpecGenAgent]\n    \u251c\u2500\u25ba Python \u2192 Rust type mapping\n    \u2514\u2500\u25ba Struct/trait generation\n    \u2193\nRust Specification\n    \u2193\n[TranspilerAgent]\n    \u251c\u2500\u25ba Mode: Pattern (CPU, fast)\n    \u2514\u2500\u25ba Mode: NeMo (GPU, high quality)\n        \u2193 HTTP\n    [NeMo Service]\n        \u2193 GPU inference\n    [NVIDIA NeMo LLM]\n    \u2193\nRust Source Code\n    \u2193\n[BuildAgent]\n    \u251c\u2500\u25ba cargo build --target wasm32-wasi\n    \u2514\u2500\u25ba Optimization (LTO, strip)\n    \u2193\nWASM Binary\n    \u2193\n[TestAgent]\n    \u251c\u2500\u25ba Conformance testing\n    \u2514\u2500\u25ba Golden test comparison\n    \u2193\nTest Results\n    \u2193\n[PackagingAgent]\n    \u251c\u2500\u25ba NIM container (GPU-enabled)\n    \u251c\u2500\u25ba Docker image\n    \u2514\u2500\u25ba Helm chart\n    \u2193\nDeployment Artifact\n    \u2193\n[Deployment]\n    \u251c\u2500\u25ba Triton Inference Server\n    \u251c\u2500\u25ba DGX Cloud (Kubernetes)\n    \u2514\u2500\u25ba Omniverse Runtime\n</code></pre>"},{"location":"architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"architecture/#1-rust-for-core-platform","title":"1. Rust for Core Platform","text":"<p>Decision: Implement core agents in Rust</p> <p>Rationale: - Memory safety without GC - High performance - WASM compilation target - Strong type system - Excellent async support (Tokio)</p> <p>Trade-offs: Steeper learning curve vs. Python</p>"},{"location":"architecture/#2-agent-based-architecture","title":"2. Agent-Based Architecture","text":"<p>Decision: Separate concerns into specialized agents</p> <p>Rationale: - Single Responsibility Principle - Independent testing and development - Parallel execution potential - Easy to swap implementations - Clear interfaces via message bus</p> <p>Trade-offs: More complex orchestration</p>"},{"location":"architecture/#3-message-bus-communication","title":"3. Message Bus Communication","text":"<p>Decision: Agents communicate via async messages</p> <p>Rationale: - Loose coupling - Easy to trace/debug - Supports distributed deployment - Enables retry and error recovery - Natural fit for async Rust</p> <p>Trade-offs: Message serialization overhead</p>"},{"location":"architecture/#4-dual-mode-transpiler","title":"4. Dual-Mode Transpiler","text":"<p>Decision: Support both pattern-based and NeMo translation</p> <p>Rationale: - Fallback when GPU unavailable - Fast development iteration (pattern mode) - High quality for production (NeMo mode) - Cost optimization (choose based on needs)</p> <p>Trade-offs: Two code paths to maintain</p>"},{"location":"architecture/#5-feature-flags-for-gpu","title":"5. Feature Flags for GPU","text":"<p>Decision: Make GPU features optional via Cargo features</p> <p>Rationale: - Core platform works without GPU - CI/CD doesn't need GPU - Easier development - Gradual adoption - Zero runtime overhead when disabled</p> <p>Trade-offs: More build configurations</p>"},{"location":"architecture/#6-http-bridge-to-nemo","title":"6. HTTP Bridge to NeMo","text":"<p>Decision: Use HTTP instead of FFI for NeMo integration</p> <p>Rationale: - Language independence (Rust \u2194 Python) - Service scalability - Easier debugging - Production-proven pattern - Supports remote deployment</p> <p>Trade-offs: Network latency (~5-20ms)</p>"},{"location":"architecture/#technology-stack","title":"Technology Stack","text":""},{"location":"architecture/#core-platform-rust","title":"Core Platform (Rust)","text":"Component Technology Purpose Language Rust 1.75+ Core implementation Async Runtime Tokio Asynchronous operations CLI Framework Clap 4.x Command-line interface Serialization Serde + JSON Message passing Python Parsing rustpython-parser AST generation Error Handling anyhow + thiserror Error propagation Logging tracing Observability HTTP Client reqwest NeMo communication"},{"location":"architecture/#nvidia-stack-pythoncudac","title":"NVIDIA Stack (Python/CUDA/C++)","text":"Component Technology Purpose NeMo PyTorch + NeMo LLM translation CUDA CUDA 12.0+ GPU kernels Triton Triton Inference Model serving NIM FastAPI + gRPC Microservices DGX Cloud Kubernetes Orchestration Omniverse Kit Extensions WASM runtime"},{"location":"architecture/#infrastructure","title":"Infrastructure","text":"Component Technology Purpose Containers Docker Packaging Orchestration Kubernetes + Helm Deployment Monitoring Prometheus + Grafana Observability Load Balancing NGINX Ingress Traffic management CI/CD GitHub Actions Automation"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/#throughput","title":"Throughput","text":"Component Metric Value Pattern Translation trans/sec 366,000 NeMo Translation ms/function 315 (P95) CUDA Parsing (10K LOC) speedup 37x Triton Serving QPS 142 End-to-End (100 LOC) ms 315 (P95)"},{"location":"architecture/#resource-usage","title":"Resource Usage","text":"Resource Usage Notes CPU (per translation) ~50ms Pattern mode GPU Utilization 82% NeMo + CUDA Memory (per agent) ~100MB Rust agents GPU Memory 2-4GB NeMo service"},{"location":"architecture/#scalability","title":"Scalability","text":"Dimension Capability Concurrent Requests 1000+ Batch Size 32 (GPU) Cluster Nodes 1-10 (auto-scaling) Files per Batch Unlimited"},{"location":"architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"architecture/#input-validation","title":"Input Validation","text":"<ul> <li>Python syntax validation</li> <li>AST safety checks</li> <li>Resource limits (file size, parse depth)</li> </ul>"},{"location":"architecture/#sandboxing","title":"Sandboxing","text":"<ul> <li>WASM execution in sandbox</li> <li>No file system access by default</li> <li>Memory limits enforced</li> </ul>"},{"location":"architecture/#service-security","title":"Service Security","text":"<ul> <li>Authentication via API keys</li> <li>Rate limiting</li> <li>TLS for all HTTP traffic</li> <li>Network policies in Kubernetes</li> </ul>"},{"location":"architecture/#container-security","title":"Container Security","text":"<ul> <li>Non-root user</li> <li>Read-only root filesystem</li> <li>No privileged containers</li> <li>Security scanning (Trivy)</li> </ul>"},{"location":"architecture/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"architecture/#metrics-collected","title":"Metrics Collected","text":"<ul> <li>Translation success/failure rates</li> <li>Latency per agent (P50, P95, P99)</li> <li>GPU utilization</li> <li>Queue depths</li> <li>Error rates by type</li> </ul>"},{"location":"architecture/#logging","title":"Logging","text":"<ul> <li>Structured logging (JSON)</li> <li>Correlation IDs for request tracing</li> <li>Log levels: TRACE, DEBUG, INFO, WARN, ERROR</li> </ul>"},{"location":"architecture/#tracing","title":"Tracing","text":"<ul> <li>Distributed tracing (planned: OpenTelemetry)</li> <li>Span per agent execution</li> <li>Request flow visualization</li> </ul>"},{"location":"architecture/#dashboards","title":"Dashboards","text":"<ul> <li>Grafana dashboards for:</li> <li>Translation pipeline metrics</li> <li>GPU utilization</li> <li>Service health</li> <li>Cost tracking</li> </ul>"},{"location":"architecture/#future-architecture-evolution","title":"Future Architecture Evolution","text":""},{"location":"architecture/#short-term-3-6-months","title":"Short Term (3-6 months)","text":"<ul> <li>OpenTelemetry distributed tracing</li> <li>gRPC API alongside REST</li> <li>Enhanced caching layer</li> <li>Multi-region deployment</li> </ul>"},{"location":"architecture/#medium-term-6-12-months","title":"Medium Term (6-12 months)","text":"<ul> <li>Streaming translation API</li> <li>Incremental compilation</li> <li>Multi-GPU training for NeMo</li> <li>Advanced optimization passes</li> </ul>"},{"location":"architecture/#long-term-12-months","title":"Long Term (12+ months)","text":"<ul> <li>Distributed agent execution</li> <li>Plugin system for custom agents</li> <li>Multi-language support (Go, Java)</li> <li>Edge deployment (WASM agents)</li> </ul>"},{"location":"architecture/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>CLI Reference</li> <li>Performance Tuning</li> <li>Deployment Guide</li> <li>Security Guide</li> </ul>"},{"location":"assessment/","title":"Portalis Assessment Tool","text":""},{"location":"assessment/#overview","title":"Overview","text":"<p>The Portalis Assessment Tool helps you evaluate Python codebases for compatibility with the Portalis Python\u2192Rust\u2192WASM translation platform. It provides detailed reports on translatability, identifies blockers, estimates migration effort, and generates actionable recommendations.</p>"},{"location":"assessment/#features","title":"Features","text":"<ul> <li>Feature Detection: Automatically scans Python code to identify language features, patterns, and dependencies</li> <li>Compatibility Analysis: Evaluates detected features against Portalis support matrix</li> <li>Effort Estimation: Calculates migration time and cost based on codebase size and complexity</li> <li>Migration Planning: Generates phased migration plans with dependency analysis</li> <li>Professional Reports: Outputs HTML, JSON, Markdown, and PDF reports</li> </ul>"},{"location":"assessment/#quick-start","title":"Quick Start","text":""},{"location":"assessment/#assess-a-python-project","title":"Assess a Python Project","text":"<pre><code>portalis assess --project /path/to/python/project --report compatibility.html\n</code></pre> <p>This will: 1. Scan all <code>.py</code> files in the project 2. Analyze detected features for compatibility 3. Calculate translatability score 4. Generate an HTML report</p>"},{"location":"assessment/#generate-a-migration-plan","title":"Generate a Migration Plan","text":"<pre><code>portalis plan --project /path/to/python/project --strategy bottom-up --output plan.md\n</code></pre> <p>This creates a phased migration plan based on dependency analysis.</p>"},{"location":"assessment/#commands","title":"Commands","text":""},{"location":"assessment/#portalis-assess","title":"<code>portalis assess</code>","text":"<p>Analyzes a Python codebase for Portalis compatibility.</p> <p>Options: - <code>-p, --project &lt;PATH&gt;</code>: Path to Python project directory (required) - <code>-r, --report &lt;FILE&gt;</code>: Output report file (default: <code>portalis-assessment.html</code>) - <code>-f, --format &lt;FORMAT&gt;</code>: Report format: <code>html</code>, <code>json</code>, <code>markdown</code>, or <code>pdf</code> (default: <code>html</code>) - <code>-v, --verbose</code>: Show detailed output during analysis</p> <p>Example: <pre><code>portalis assess \\\n    --project ./my-python-app \\\n    --report my-app-assessment.html \\\n    --format html \\\n    --verbose\n</code></pre></p> <p>Output: - Translatability percentage - Feature breakdown (supported/partial/unsupported) - Critical blockers list - Effort estimate (hours/weeks) - Executive summary with recommendations</p>"},{"location":"assessment/#portalis-plan","title":"<code>portalis plan</code>","text":"<p>Generates a migration plan with phased approach.</p> <p>Options: - <code>-p, --project &lt;PATH&gt;</code>: Path to Python project directory (required) - <code>-s, --strategy &lt;STRATEGY&gt;</code>: Migration strategy (default: <code>bottom-up</code>)   - <code>full</code>: Translate everything at once   - <code>incremental</code>: Batch migration (5 modules at a time)   - <code>bottom-up</code>: Dependencies first (safest)   - <code>top-down</code>: Top-level modules first   - <code>critical-path</code>: High-impact modules first - <code>-o, --output &lt;FILE&gt;</code>: Output plan file (Markdown) - <code>-v, --verbose</code>: Show all modules in each phase</p> <p>Example: <pre><code>portalis plan \\\n    --project ./my-python-app \\\n    --strategy bottom-up \\\n    --output migration-plan.md \\\n    --verbose\n</code></pre></p> <p>Output: - Migration strategy explanation - Phased module list - Estimated duration per phase - Dependencies and risks - Recommendations for each strategy</p>"},{"location":"assessment/#understanding-the-assessment-report","title":"Understanding the Assessment Report","text":""},{"location":"assessment/#executive-summary","title":"Executive Summary","text":"<p>High-level overview for stakeholders: - Recommendation: Whether migration is recommended - Translatability: Overall compatibility percentage - Estimated Time: Project duration (weeks/months) - Estimated Cost: Budget range (based on $150/hour) - Key Risks: Top blockers that must be addressed - Key Benefits: Expected improvements from migration</p>"},{"location":"assessment/#compatibility-score","title":"Compatibility Score","text":"<p>Detailed breakdown: - Overall Score: Weighted average (full=1.0, partial=0.5, none=0.0) - Fully Supported: Features that translate perfectly - Partially Supported: Features with limitations - Unsupported (Blockers): Features that prevent translation</p>"},{"location":"assessment/#translation-blockers","title":"Translation Blockers","text":"<p>Critical issues that must be resolved:</p> <p>Impact Levels: - Critical: Prevents translation entirely (e.g., metaclasses, <code>eval()</code>) - High: Prevents specific modules (e.g., <code>__getattr__</code>) - Medium: Requires refactoring (e.g., abstract methods) - Low: Minor workarounds needed</p> <p>Each blocker includes: - Feature name and occurrence count - Description of the issue - Suggested workaround (if available) - File locations</p>"},{"location":"assessment/#effort-estimate","title":"Effort Estimate","text":"<p>Time and cost breakdown: - Analysis: Initial investigation (2-3% of total) - Refactoring: Removing blockers (varies by compatibility) - Translation: Core migration work (40-50% of total) - Testing: Validation and bug fixes (30-40% of total) - Integration: Deployment setup (5-10% of total) - Documentation: API docs and guides (5-10% of total)</p>"},{"location":"assessment/#migration-timeline","title":"Migration Timeline","text":"<p>Phased delivery plan: 1. Analysis &amp; Planning: Assessment and strategy 2. Refactoring: Remove blockers (if needed) 3. Translation: Python \u2192 Rust \u2192 WASM 4. Testing &amp; Validation: Ensure correctness 5. Integration: Deploy to production 6. Documentation: User and developer docs</p>"},{"location":"assessment/#feature-support-matrix","title":"Feature Support Matrix","text":""},{"location":"assessment/#fully-supported","title":"Fully Supported (\u2705)","text":"<ul> <li>Functions with type hints</li> <li>Classes with <code>__init__</code></li> <li>Basic methods (<code>__str__</code>, <code>__repr__</code>, <code>__eq__</code>, etc.)</li> <li>Standard decorators (<code>@property</code>, <code>@staticmethod</code>, <code>@classmethod</code>)</li> <li>Arithmetic operators (<code>__add__</code>, <code>__sub__</code>, <code>__mul__</code>, etc.)</li> <li>Collection access (<code>__len__</code>, <code>__getitem__</code>, <code>__setitem__</code>)</li> <li>Most standard library imports</li> </ul>"},{"location":"assessment/#partially-supported","title":"Partially Supported (\u26a0\ufe0f)","text":"<ul> <li>Async/await (basic patterns only)</li> <li>Dataclasses (simple fields only)</li> <li>Context managers (<code>__enter__</code>, <code>__exit__</code>)</li> <li>Callable classes (<code>__call__</code>)</li> <li>Generic types (limited)</li> <li>Some decorators (<code>@lru_cache</code>)</li> </ul>"},{"location":"assessment/#not-supported","title":"Not Supported (\u274c)","text":"<ul> <li>Metaclasses: Requires runtime introspection</li> <li>Dynamic execution: <code>eval()</code>, <code>exec()</code>, <code>compile()</code></li> <li>Dynamic attributes: <code>__getattr__</code>, <code>__setattr__</code></li> <li>Abstract methods: <code>@abstractmethod</code> (use traits instead)</li> <li>Introspection: <code>inspect</code> module</li> <li>Some magic methods: Depending on complexity</li> </ul>"},{"location":"assessment/#migration-strategies","title":"Migration Strategies","text":""},{"location":"assessment/#full-migration","title":"Full Migration","text":"<p>When to use: - Small projects (&lt;1000 LOC) - High compatibility (&gt;90%) - Can afford downtime</p> <p>Pros: - Fastest path to completion - No dual-system complexity - Immediate benefits</p> <p>Cons: - Higher risk - Requires complete freeze - All-or-nothing approach</p>"},{"location":"assessment/#incremental-migration","title":"Incremental Migration","text":"<p>When to use: - Medium projects (1K-10K LOC) - Good compatibility (70-90%) - Need gradual rollout</p> <p>Pros: - Lower risk per batch - Can roll back easily - Continuous deployment</p> <p>Cons: - Longer total timeline - Dual-system maintenance - Integration complexity</p>"},{"location":"assessment/#bottom-up-migration","title":"Bottom-Up Migration","text":"<p>When to use: - Projects with clear dependencies - Need maximum safety - Complex dependency graph</p> <p>Pros: - Safest approach - Dependencies always ready - Can run both versions in parallel</p> <p>Cons: - Slower to see benefits - Requires dependency analysis - May need temporary adapters</p>"},{"location":"assessment/#top-down-migration","title":"Top-Down Migration","text":"<p>When to use: - Want quick wins - Tight deadline - Critical path focus</p> <p>Pros: - Fast time to value - User-facing features first - Clear progress</p> <p>Cons: - Requires temporary shims - Higher risk - May break abstractions</p>"},{"location":"assessment/#critical-path-migration","title":"Critical Path Migration","text":"<p>When to use: - Performance bottlenecks identified - ROI-focused approach - Resource constraints</p> <p>Pros: - Maximize business value - Focus on what matters - Flexible prioritization</p> <p>Cons: - May need refactoring - Complex dependencies - Requires good judgment</p>"},{"location":"assessment/#best-practices","title":"Best Practices","text":""},{"location":"assessment/#before-assessment","title":"Before Assessment","text":"<ol> <li>Update Dependencies: Ensure Python packages are current</li> <li>Run Tests: Verify existing test coverage</li> <li>Document Patterns: Note any unusual code patterns</li> <li>Identify Owners: Know who owns each module</li> </ol>"},{"location":"assessment/#during-assessment","title":"During Assessment","text":"<ol> <li>Review Blockers: Understand each blocker's impact</li> <li>Validate Metrics: Check LOC and complexity estimates</li> <li>Consult Team: Discuss feasibility with developers</li> <li>Plan Refactoring: Identify blocker removal strategies</li> </ol>"},{"location":"assessment/#after-assessment","title":"After Assessment","text":"<ol> <li>Prioritize Work: Focus on high-impact blockers</li> <li>Prototype: Test translation on critical modules</li> <li>Set Milestones: Define clear success criteria</li> <li>Track Progress: Monitor metrics during migration</li> </ol>"},{"location":"assessment/#troubleshooting","title":"Troubleshooting","text":""},{"location":"assessment/#low-compatibility-score-50","title":"Low Compatibility Score (&lt;50%)","text":"<p>Likely causes: - Heavy use of metaclasses - Dynamic code generation - Complex introspection</p> <p>Solutions: - Refactor to use composition - Replace dynamic code with static - Consider alternative approaches</p>"},{"location":"assessment/#high-effort-estimate-6-months","title":"High Effort Estimate (&gt;6 months)","text":"<p>Likely causes: - Large codebase (&gt;50K LOC) - Many blockers - Complex dependencies</p> <p>Solutions: - Split into smaller projects - Focus on critical modules first - Consider partial migration</p>"},{"location":"assessment/#circular-dependencies","title":"Circular Dependencies","text":"<p>Symptoms: - Plan command fails - \"Circular dependency detected\" error</p> <p>Solutions: - Refactor to break cycles - Use dependency injection - Restructure module hierarchy</p>"},{"location":"assessment/#examples","title":"Examples","text":""},{"location":"assessment/#example-1-simple-calculator","title":"Example 1: Simple Calculator","text":"<pre><code># Assess the sample calculator project\nportalis assess --project examples/assessment-reports/sample-project --verbose\n\n# Output:\n# Translatability: 95%\n# Fully Supported: 18 features\n# Blockers: 0\n# Estimated Effort: 2-3 days\n</code></pre>"},{"location":"assessment/#example-2-web-framework","title":"Example 2: Web Framework","text":"<pre><code># Assess a larger web application\nportalis assess --project ~/projects/my-web-app --report webapp-assessment.html\n\n# Generate migration plan\nportalis plan --project ~/projects/my-web-app --strategy incremental\n</code></pre>"},{"location":"assessment/#example-3-data-processing-pipeline","title":"Example 3: Data Processing Pipeline","text":"<pre><code># Check compatibility for data pipeline\nportalis assess --project ~/data-pipeline --format json &gt; pipeline-report.json\n\n# Parse with jq\njq '.compatibility.score.overall' pipeline-report.json\n</code></pre>"},{"location":"assessment/#faq","title":"FAQ","text":"<p>Q: How accurate are the effort estimates? A: Estimates are based on industry averages and code complexity. Actual time may vary \u00b130% based on team experience and code quality.</p> <p>Q: Can I customize the feature support matrix? A: Not currently, but this is planned for future releases. You can modify the source code in <code>core/src/assessment/feature_detector.rs</code>.</p> <p>Q: What if my code uses unsupported features? A: Review the suggested workarounds in the report. Many unsupported features can be refactored to use supported patterns.</p> <p>Q: How often should I re-assess? A: Re-assess after: - Major refactoring - Adding new features - Before starting migration - After each migration phase</p> <p>Q: Can I use this for other languages? A: Currently Python-only. Support for other languages may be added in future versions.</p>"},{"location":"assessment/#support","title":"Support","text":"<p>For issues or questions: - GitHub Issues: https://github.com/portalis/portalis/issues - Documentation: https://docs.portalis.dev - Community: https://discord.gg/portalis</p>"},{"location":"assessment/#contributing","title":"Contributing","text":"<p>We welcome contributions! See <code>CONTRIBUTING.md</code> for guidelines.</p>"},{"location":"assessment/#license","title":"License","text":"<p>MIT License - see <code>LICENSE</code> file for details.</p>"},{"location":"beta-program/","title":"PORTALIS BETA PROGRAM GUIDE","text":"<p>Version: 1.0 Date: October 2025 Status: Active Enrollment</p>"},{"location":"beta-program/#program-overview","title":"Program Overview","text":"<p>The Portalis Beta Program provides early access to our GPU-accelerated Python-to-Rust-to-WASM translation platform. Beta participants will help validate real-world performance, identify edge cases, and shape the product roadmap before general availability.</p>"},{"location":"beta-program/#what-is-portalis","title":"What is Portalis?","text":"<p>Portalis is a production-ready AI-powered code translation platform that converts Python applications to high-performance Rust code, compiled to WebAssembly (WASM). The platform leverages NVIDIA's complete GPU stack for unprecedented performance:</p> <ul> <li>2-3x faster translation than CPU-based approaches</li> <li>NVIDIA NeMo for intelligent code translation</li> <li>CUDA acceleration for parallel AST parsing</li> <li>Triton Inference Server for scalable model serving</li> <li>DGX Cloud for distributed processing</li> <li>Omniverse integration for WASM runtime validation</li> </ul>"},{"location":"beta-program/#program-goals","title":"Program Goals","text":""},{"location":"beta-program/#for-participants","title":"For Participants","text":"<ol> <li>Early Access: Get exclusive access to cutting-edge translation technology</li> <li>Performance Benefits: Experience 2-3x faster Python\u2192Rust\u2192WASM conversions</li> <li>Cost Savings: Reduce translation costs by up to 92% ($0.008 per translation)</li> <li>Direct Influence: Shape product features and roadmap</li> <li>Technical Support: Dedicated engineering support during beta period</li> <li>Case Study Opportunity: Potential to be featured as a success story</li> </ol>"},{"location":"beta-program/#for-portalis","title":"For Portalis","text":"<ol> <li>Real-World Validation: Test platform with diverse Python codebases</li> <li>Performance Tuning: Optimize for actual user workloads</li> <li>Feature Prioritization: Understand critical customer needs</li> <li>Quality Assurance: Identify edge cases and bugs before GA</li> <li>Documentation Improvement: Refine guides based on user feedback</li> <li>Success Stories: Build case studies for marketing</li> </ol>"},{"location":"beta-program/#participation-requirements","title":"Participation Requirements","text":""},{"location":"beta-program/#technical-requirements","title":"Technical Requirements","text":"<p>Minimum Requirements: - Python codebase: 1,000-100,000 lines of code - Python version: 3.8+ (3.9, 3.10, 3.11 supported) - Willingness to test translations with production workloads - Ability to provide performance benchmarks</p> <p>Recommended Requirements: - CI/CD pipeline for integration - Test suite for validation (pytest, unittest) - Access to NVIDIA GPU for local testing (optional) - Docker/Kubernetes environment (for containerized deployments)</p>"},{"location":"beta-program/#organizational-requirements","title":"Organizational Requirements","text":"<p>Commitment: - Dedicated technical contact (min 5 hours/week) - Executive sponsor for decision-making - Willingness to provide detailed feedback - Participation in weekly check-ins (30 min) - Minimum 3-month engagement</p> <p>Resources: - 1-2 engineers for integration and testing - QA resource for validation - Infrastructure for deployment (cloud or on-premise)</p>"},{"location":"beta-program/#legal-requirements","title":"Legal Requirements","text":"<ul> <li>Signed Beta Agreement (NDA + Terms of Service)</li> <li>Acceptance of early-access limitations</li> <li>Permission to use anonymized metrics</li> <li>Optional: Permission for public case study</li> </ul>"},{"location":"beta-program/#program-benefits","title":"Program Benefits","text":""},{"location":"beta-program/#what-you-get","title":"What You Get","text":"<p>Technology Access: - \u2705 Full Portalis platform access (all features) - \u2705 NVIDIA GPU-accelerated translation - \u2705 Unlimited translations during beta period - \u2705 API access + CLI tools + Web UI - \u2705 Docker/Kubernetes deployment packages - \u2705 Complete documentation and guides</p> <p>Support &amp; Services: - \u2705 Dedicated Slack/Discord channel - \u2705 Weekly office hours with engineering team - \u2705 Priority bug fixes (24-48 hour SLA) - \u2705 Custom integration assistance - \u2705 Performance optimization consultation - \u2705 Migration planning support</p> <p>Early Adopter Advantages: - \u2705 50% discount on first 12 months post-GA - \u2705 Feature request prioritization - \u2705 Beta participant badge/recognition - \u2705 Early access to new capabilities - \u2705 Case study co-marketing opportunity</p>"},{"location":"beta-program/#what-we-ask","title":"What We Ask","text":"<p>Feedback &amp; Data: - Regular feedback on functionality and performance - Bug reports with reproducible test cases - Feature requests with business justification - Anonymous usage metrics and telemetry - Benchmark data for performance validation</p> <p>Participation: - Weekly 30-minute check-in calls - Monthly retrospective meetings - Completion of feedback surveys - Testing of new features/releases - Documentation review and suggestions</p> <p>Success Metrics: - Minimum 10 successful translations - At least 1 production integration - Complete feedback survey - Participate in case study (optional)</p>"},{"location":"beta-program/#support-channels","title":"Support Channels","text":""},{"location":"beta-program/#primary-support","title":"Primary Support","text":"<p>Beta Support Slack Channel: - URL: portalis-beta.slack.com - Response Time: &lt;4 hours (business hours) - Available: Mon-Fri, 9 AM - 6 PM PT - Channels:   - <code>#beta-general</code> - General discussion   - <code>#beta-technical</code> - Technical issues   - <code>#beta-features</code> - Feature requests   - <code>#beta-performance</code> - Performance optimization</p> <p>Email Support: - Address: beta-support@portalis.ai - Response Time: &lt;24 hours - For: Non-urgent issues, documentation questions</p>"},{"location":"beta-program/#escalation-path","title":"Escalation Path","text":"<p>Level 1: Community Support (Slack) - Beta participants + community managers - Response: &lt;4 hours - For: General questions, how-to, best practices</p> <p>Level 2: Engineering Support (Ticket) - Senior engineers assigned to beta program - Response: &lt;24 hours - For: Technical issues, integration problems, bugs</p> <p>Level 3: Critical Issues (Phone/Video) - Engineering leadership + product team - Response: &lt;2 hours - For: Production blockers, critical bugs, security issues</p> <p>Emergency Hotline: +1 (555) 123-BETA - 24/7 availability for critical production issues</p>"},{"location":"beta-program/#feedback-process","title":"Feedback Process","text":""},{"location":"beta-program/#how-to-provide-feedback","title":"How to Provide Feedback","text":"<p>1. Weekly Check-Ins (Structured) - 30-minute video call every Monday - Review previous week's progress - Discuss current issues and blockers - Plan upcoming tests and integrations</p> <p>2. Feedback Surveys (Monthly) - Comprehensive product feedback survey - NPS (Net Promoter Score) measurement - Feature prioritization voting - Documentation quality assessment</p> <p>3. Bug Reports (As Needed) - GitHub Issues: github.com/portalis/beta-issues - Include: reproduction steps, logs, environment - Expected vs actual behavior - Screenshots/recordings if applicable</p> <p>4. Feature Requests (As Needed) - Product feedback board: feedback.portalis.ai - Business justification required - Use case description - Priority ranking (P0-P3)</p>"},{"location":"beta-program/#feedback-categories","title":"Feedback Categories","text":"<p>Critical (P0): - Production blockers - Data loss or corruption - Security vulnerabilities - Incorrect translations causing runtime errors</p> <p>High (P1): - Significant performance degradation - Missing critical features - Poor documentation - Integration issues</p> <p>Medium (P2): - Minor bugs or issues - Enhancement requests - Documentation improvements - UX/UI suggestions</p> <p>Low (P3): - Nice-to-have features - Cosmetic issues - Minor optimizations</p>"},{"location":"beta-program/#success-metrics","title":"Success Metrics","text":""},{"location":"beta-program/#translation-quality-metrics","title":"Translation Quality Metrics","text":"<p>Target: &gt;90% Success Rate</p> <p>Measured By: - Successful compilation rate (Rust builds) - WASM validation pass rate - Runtime correctness (test suite pass rate) - Type inference accuracy - API compatibility preservation</p> <p>Tracking: - Automated metrics in dashboard - Weekly quality reports - Anomaly detection and alerts</p>"},{"location":"beta-program/#customer-satisfaction-metrics","title":"Customer Satisfaction Metrics","text":"<p>Target: &gt;4.0/5.0 Average</p> <p>Measured By: - Overall satisfaction rating (1-5 scale) - Net Promoter Score (NPS): &gt;30 - Feature satisfaction (per-feature ratings) - Documentation clarity (1-5 scale) - Support responsiveness (1-5 scale)</p> <p>Collection: - Monthly satisfaction surveys - Post-translation feedback - Quarterly NPS surveys</p>"},{"location":"beta-program/#support-metrics","title":"Support Metrics","text":"<p>Target: &lt;24 Hour Response Time</p> <p>Measured By: - First response time (P95 &lt;4 hours) - Resolution time by severity:   - P0 (Critical): &lt;2 hours   - P1 (High): &lt;24 hours   - P2 (Medium): &lt;72 hours   - P3 (Low): &lt;1 week - Support ticket volume trends</p> <p>Tracking: - Zendesk/Freshdesk metrics - Weekly support reports</p>"},{"location":"beta-program/#quality-metrics","title":"Quality Metrics","text":"<p>Target: 0 Critical Bugs</p> <p>Measured By: - Critical bug count (must be 0) - Major bug count (target &lt;5) - Minor bug count (target &lt;20) - Time to resolution by severity - Regression rate (&lt;5%)</p> <p>Tracking: - GitHub Issues dashboard - Weekly bug triage meetings - Automated test suite results</p>"},{"location":"beta-program/#documentation-metrics","title":"Documentation Metrics","text":"<p>Target: 100% Completeness</p> <p>Measured By: - API coverage: 100% of endpoints documented - Feature coverage: All features have guides - Tutorial completeness: End-to-end workflows - FAQ coverage: All common questions answered - Code examples: All major use cases covered</p> <p>Validation: - Documentation review checklist - User feedback on clarity - Time to first successful translation</p>"},{"location":"beta-program/#platform-performance-metrics","title":"Platform Performance Metrics","text":"<p>Target: Meet/Exceed SLAs</p> <p>Measured By: - Translation latency (P95 &lt;500ms for 100 LOC) - Throughput (&gt;200 req/s batch processing) - System uptime (&gt;99.5%) - GPU utilization (&gt;70%) - Cost per translation (&lt;$0.01)</p> <p>Tracking: - Prometheus metrics - Grafana dashboards - Weekly performance reports</p>"},{"location":"beta-program/#timeline-and-milestones","title":"Timeline and Milestones","text":""},{"location":"beta-program/#program-duration-12-weeks-3-months","title":"Program Duration: 12 Weeks (3 Months)","text":""},{"location":"beta-program/#phase-1-onboarding-weeks-1-2","title":"Phase 1: Onboarding (Weeks 1-2)","text":"<p>Week 1: Setup - Beta agreement signed - Account provisioning - Initial training session - Environment setup - First test translation</p> <p>Week 2: Integration - API integration complete - CI/CD pipeline configured - First production-like translation - Performance baseline established - Feedback process confirmed</p> <p>Milestone: First successful translation \u2705</p>"},{"location":"beta-program/#phase-2-active-testing-weeks-3-8","title":"Phase 2: Active Testing (Weeks 3-8)","text":"<p>Week 3-4: Core Features - Test basic translation workflows - Validate type inference - Test build pipeline - Evaluate documentation - Report initial findings</p> <p>Week 5-6: Advanced Features - GPU acceleration testing - Batch processing validation - NIM microservice deployment - Performance optimization - Integration edge cases</p> <p>Week 7-8: Production Simulation - Production workload testing - Stress testing - Failure scenario validation - Monitoring and alerting - Cost analysis</p> <p>Milestone: Production-ready integration \u2705</p>"},{"location":"beta-program/#phase-3-optimization-weeks-9-10","title":"Phase 3: Optimization (Weeks 9-10)","text":"<p>Week 9: Performance Tuning - Benchmark analysis - Optimization implementation - A/B testing - Cost optimization - SLA validation</p> <p>Week 10: Final Validation - Full regression testing - Documentation validation - Case study preparation - Success metrics review - Final feedback collection</p> <p>Milestone: Performance targets met \u2705</p>"},{"location":"beta-program/#phase-4-graduation-weeks-11-12","title":"Phase 4: Graduation (Weeks 11-12)","text":"<p>Week 11: Transition Planning - GA readiness assessment - Production deployment plan - Pricing discussion - Contract negotiation - Case study finalization</p> <p>Week 12: Program Completion - Final retrospective - Lessons learned documentation - Beta graduation ceremony - Early adopter benefits activation - Ongoing support transition</p> <p>Milestone: Beta graduation to production \u2705</p>"},{"location":"beta-program/#program-structure","title":"Program Structure","text":""},{"location":"beta-program/#governance","title":"Governance","text":"<p>Beta Program Lead: - Overall program management - Stakeholder communication - Success metrics tracking - Escalation management</p> <p>Technical Lead: - Platform stability and performance - Bug triage and prioritization - Technical support escalation - Architecture decisions</p> <p>Product Manager: - Feature prioritization - Roadmap alignment - Requirements gathering - User experience optimization</p>"},{"location":"beta-program/#communication-cadence","title":"Communication Cadence","text":"<p>Daily: - Slack channel monitoring - Ticket response - Emergency escalations</p> <p>Weekly: - 30-min check-in calls (per participant) - Engineering office hours (1 hour) - Bug triage meeting (internal) - Metrics review (internal)</p> <p>Monthly: - Retrospective meeting (1 hour) - Satisfaction survey - Progress report to participants - Executive stakeholder update</p> <p>Quarterly: - In-person/virtual summit - Roadmap review - Strategic planning - Networking event</p>"},{"location":"beta-program/#enrollment-process","title":"Enrollment Process","text":""},{"location":"beta-program/#how-to-apply","title":"How to Apply","text":"<p>Step 1: Application Submission - Complete application form: apply.portalis.ai/beta - Provide company and technical details - Describe use case and codebase - Submit Python codebase sample (optional)</p> <p>Step 2: Review &amp; Selection - Application review (3-5 business days) - Technical fit assessment - Use case evaluation - Capacity check</p> <p>Step 3: Acceptance &amp; Onboarding - Acceptance notification - Beta agreement signing - Account provisioning - Welcome kit delivery - Onboarding session scheduled</p> <p>Step 4: Kickoff - Initial training session - Environment setup - First translation walkthrough - Support channel access - Success metrics baseline</p>"},{"location":"beta-program/#selection-criteria","title":"Selection Criteria","text":"<p>We Look For: - Diverse Python codebases (size, complexity, domain) - Active development teams (committed participation) - Production use cases (real-world validation) - Technical sophistication (can provide detailed feedback) - Strategic fit (industries we're targeting)</p> <p>Ideal Participants: - FinTech, Data Science, ML/AI, SaaS companies - 10-500 employee companies - Active Python development (5+ engineers) - Cloud-native or containerized deployments - Performance-sensitive applications</p>"},{"location":"beta-program/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"beta-program/#general-questions","title":"General Questions","text":"<p>Q: Is the beta program free? A: Yes, beta access is completely free during the program period. You'll receive a 50% discount for 12 months after GA.</p> <p>Q: How long does the beta program last? A: The program runs for 12 weeks (3 months) per participant. You can extend if needed.</p> <p>Q: What happens after beta? A: You transition to a production subscription with early adopter pricing (50% off for 12 months).</p> <p>Q: Can we use Portalis in production during beta? A: Yes, with the understanding that it's pre-GA software. We recommend thorough testing and gradual rollout.</p>"},{"location":"beta-program/#technical-questions","title":"Technical Questions","text":"<p>Q: Do we need NVIDIA GPUs? A: No, the platform works on CPU-only environments. GPU acceleration is optional for better performance.</p> <p>Q: What Python versions are supported? A: Python 3.8, 3.9, 3.10, and 3.11 are fully supported. Python 3.7 and 3.12 are in development.</p> <p>Q: Can we translate existing production code? A: Yes, that's encouraged. We recommend starting with non-critical modules and gradually expanding.</p> <p>Q: What if translations fail? A: We provide detailed error messages and fallback options. Our support team will help resolve any issues.</p>"},{"location":"beta-program/#support-questions","title":"Support Questions","text":"<p>Q: What's the SLA for bug fixes? A: Critical bugs: &lt;2 hours response, &lt;24 hours resolution. High priority: &lt;24 hours response, &lt;72 hours resolution.</p> <p>Q: Can we get custom features developed? A: Feature requests are prioritized based on beta participant needs. We'll work with you on critical requirements.</p> <p>Q: Is there a dedicated support engineer? A: Yes, each beta participant gets a designated customer success engineer and access to the engineering team.</p>"},{"location":"beta-program/#contact-information","title":"Contact Information","text":""},{"location":"beta-program/#program-management","title":"Program Management","text":"<p>Beta Program Director: Sarah Chen Email: sarah.chen@portalis.ai Phone: +1 (555) 123-4567</p> <p>Technical Program Manager: Alex Rodriguez Email: alex.rodriguez@portalis.ai Phone: +1 (555) 234-5678</p>"},{"location":"beta-program/#support-contacts","title":"Support Contacts","text":"<p>Beta Support Email: beta-support@portalis.ai Emergency Hotline: +1 (555) 123-BETA Slack Workspace: portalis-beta.slack.com Application Portal: apply.portalis.ai/beta</p>"},{"location":"beta-program/#online-resources","title":"Online Resources","text":"<p>Documentation: docs.portalis.ai/beta API Reference: api.portalis.ai/docs Feedback Portal: feedback.portalis.ai Status Page: status.portalis.ai Community Forum: community.portalis.ai</p>"},{"location":"beta-program/#appendix-beta-agreement-summary","title":"Appendix: Beta Agreement Summary","text":""},{"location":"beta-program/#key-terms","title":"Key Terms","text":"<p>Duration: 12 weeks, renewable by mutual agreement</p> <p>License: Non-exclusive, non-transferable beta license</p> <p>Support: Business hours support with escalation for critical issues</p> <p>Data: Anonymous usage metrics collected, no code stored without permission</p> <p>IP: You retain all rights to your code and translations</p> <p>Confidentiality: NDA covers platform internals, not translated output</p> <p>Termination: Either party can terminate with 7 days notice</p> <p>Liability: Limited liability for beta software, production use at your discretion</p>"},{"location":"beta-program/#rights-obligations","title":"Rights &amp; Obligations","text":"<p>Your Rights: - Use Portalis for internal development and testing - Provide feedback and feature requests - Access all platform features and updates - Receive dedicated support - Opt-out of case study participation</p> <p>Your Obligations: - Provide regular feedback - Report bugs and issues - Participate in scheduled check-ins - Protect confidential information - Use platform in good faith</p> <p>Our Rights: - Modify platform and features - Use anonymous feedback and metrics - Discontinue beta access if terms violated - Feature your success story (with permission)</p> <p>Our Obligations: - Provide stable, functional platform - Deliver committed support SLAs - Protect your data and IP - Act on critical feedback - Provide advance notice of changes</p> <p>Last Updated: October 2025 Version: 1.0 Status: Active</p> <p>For the latest version of this guide, visit: docs.portalis.ai/beta-program</p> <p>Join the Portalis Beta Program and be part of the future of code translation!</p>"},{"location":"cli-reference/","title":"CLI Reference","text":"<p>Complete command-line reference for Portalis.</p>"},{"location":"cli-reference/#installation","title":"Installation","text":"<p>See Getting Started for installation instructions.</p>"},{"location":"cli-reference/#global-options","title":"Global Options","text":"<p>These options are available for all commands:</p> <pre><code>portalis [OPTIONS] &lt;COMMAND&gt;\n</code></pre> Option Description Default <code>--help</code>, <code>-h</code> Show help information - <code>--version</code>, <code>-V</code> Show version information - <code>--config &lt;FILE&gt;</code> Path to configuration file <code>./portalis.toml</code> <code>--verbose</code>, <code>-v</code> Increase logging verbosity <code>info</code> <code>--quiet</code>, <code>-q</code> Suppress non-error output - <code>--color &lt;WHEN&gt;</code> Color output: always, auto, never <code>auto</code>"},{"location":"cli-reference/#environment-variables","title":"Environment Variables","text":"<pre><code># Logging configuration\nRUST_LOG=debug              # Log level: trace, debug, info, warn, error\nRUST_BACKTRACE=1            # Enable backtrace on errors\n\n# Service endpoints\nNEMO_SERVICE_URL=http://localhost:8000      # NeMo translation service\nTRITON_URL=http://localhost:8001            # Triton inference server\nDGX_CLOUD_URL=https://api.dgx-cloud.nvidia.com\n\n# GPU configuration\nCUDA_VISIBLE_DEVICES=0      # CUDA device selection\nCUDA_LAUNCH_BLOCKING=1      # Synchronous CUDA operations (debugging)\n\n# Performance tuning\nPORTALIS_BATCH_SIZE=32      # Batch size for GPU operations\nPORTALIS_WORKERS=4          # Parallel workers for batch translation\nPORTALIS_CACHE_DIR=~/.cache/portalis    # Cache directory\n</code></pre>"},{"location":"cli-reference/#commands","title":"Commands","text":""},{"location":"cli-reference/#translate-translate-python-to-wasm","title":"<code>translate</code> - Translate Python to WASM","text":"<p>Translate a single Python file to WASM.</p> <pre><code>portalis translate [OPTIONS] --input &lt;FILE&gt;\n</code></pre>"},{"location":"cli-reference/#options","title":"Options","text":"Option Short Description Default <code>--input &lt;FILE&gt;</code> <code>-i</code> Input Python file (required) - <code>--output &lt;FILE&gt;</code> <code>-o</code> Output WASM file <code>&lt;input&gt;.wasm</code> <code>--mode &lt;MODE&gt;</code> <code>-m</code> Translation mode: pattern, nemo <code>pattern</code> <code>--show-rust</code> Display generated Rust code <code>false</code> <code>--save-rust &lt;FILE&gt;</code> Save Rust code to file - <code>--temperature &lt;FLOAT&gt;</code> NeMo sampling temperature (0.0-1.0) <code>0.2</code> <code>--opt-level &lt;N&gt;</code> <code>-O</code> Optimization level: 0, 1, 2, 3, s, z <code>3</code> <code>--strip-debug</code> Strip debug symbols <code>false</code> <code>--run-tests</code> Run conformance tests <code>true</code> <code>--no-tests</code> Skip conformance tests -"},{"location":"cli-reference/#examples","title":"Examples","text":"<pre><code># Basic translation\nportalis translate --input hello.py\n\n# High-quality translation with NeMo\nportalis translate --input app.py --mode nemo --output app.wasm\n\n# Save intermediate Rust code\nportalis translate --input lib.py --save-rust lib.rs --show-rust\n\n# Maximum optimization\nportalis translate --input compute.py -O z --strip-debug\n\n# Fast development mode (skip tests)\nportalis translate --input draft.py --no-tests --mode pattern\n</code></pre>"},{"location":"cli-reference/#translation-modes","title":"Translation Modes","text":"<p>Pattern-Based Mode (<code>--mode pattern</code>): - Fast CPU-based translation - ~366,000 translations/second - Best for simple functions and development - No GPU required - Limited to well-defined patterns</p> <p>NeMo Mode (<code>--mode nemo</code>): - AI-powered translation with NVIDIA NeMo - 2-3x overall speedup - Handles complex Python features - Requires GPU and NeMo service - 98.5% translation success rate</p>"},{"location":"cli-reference/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Translation failed 2 Invalid input file 3 Tests failed 4 Service unavailable (NeMo)"},{"location":"cli-reference/#batch-batch-translation","title":"<code>batch</code> - Batch Translation","text":"<p>Translate multiple Python files in batch.</p> <pre><code>portalis batch [OPTIONS] --input-dir &lt;DIR&gt;\n</code></pre>"},{"location":"cli-reference/#options_1","title":"Options","text":"Option Short Description Default <code>--input-dir &lt;DIR&gt;</code> <code>-i</code> Input directory with Python files - <code>--output-dir &lt;DIR&gt;</code> <code>-o</code> Output directory for WASM files <code>./dist</code> <code>--pattern &lt;GLOB&gt;</code> <code>-p</code> File pattern to match <code>**/*.py</code> <code>--parallel &lt;N&gt;</code> <code>-j</code> Number of parallel workers CPU cores <code>--mode &lt;MODE&gt;</code> <code>-m</code> Translation mode <code>pattern</code> <code>--recursive</code> <code>-r</code> Recursively search subdirectories <code>true</code> <code>--preserve-structure</code> Maintain directory structure <code>true</code> <code>--fail-fast</code> Stop on first error <code>false</code> <code>--continue-on-error</code> Continue after errors <code>true</code>"},{"location":"cli-reference/#examples_1","title":"Examples","text":"<pre><code># Translate all Python files in a directory\nportalis batch --input-dir ./src --output-dir ./dist\n\n# Parallel translation with 8 workers\nportalis batch -i ./src -o ./dist --parallel 8\n\n# Translate specific files\nportalis batch -i ./src -p \"**/*_lib.py\" --mode nemo\n\n# Fast CI/CD translation\nportalis batch -i ./src -o ./build --mode pattern --fail-fast\n</code></pre>"},{"location":"cli-reference/#test-run-conformance-tests","title":"<code>test</code> - Run Conformance Tests","text":"<p>Verify Python-to-Rust translation correctness.</p> <pre><code>portalis test [OPTIONS] --input &lt;FILE&gt;\n</code></pre>"},{"location":"cli-reference/#options_2","title":"Options","text":"Option Short Description Default <code>--input &lt;FILE&gt;</code> <code>-i</code> Python file to test - <code>--wasm &lt;FILE&gt;</code> <code>-w</code> WASM file to test <code>&lt;input&gt;.wasm</code> <code>--test-cases &lt;FILE&gt;</code> <code>-t</code> Custom test cases (JSON) Auto-generated <code>--coverage</code> Generate coverage report <code>false</code> <code>--benchmark</code> Run performance benchmarks <code>false</code>"},{"location":"cli-reference/#examples_2","title":"Examples","text":"<pre><code># Test translated WASM\nportalis test --input calculator.py --wasm calculator.wasm\n\n# Generate coverage report\nportalis test --input app.py --coverage\n\n# Benchmark performance\nportalis test --input compute.py --benchmark\n</code></pre>"},{"location":"cli-reference/#package-package-for-deployment","title":"<code>package</code> - Package for Deployment","text":"<p>Package WASM for deployment (NIM containers, Triton, etc.).</p> <pre><code>portalis package [OPTIONS] --input &lt;FILE&gt;\n</code></pre>"},{"location":"cli-reference/#options_3","title":"Options","text":"Option Short Description Default <code>--input &lt;FILE&gt;</code> <code>-i</code> Input WASM file - <code>--output &lt;FILE&gt;</code> <code>-o</code> Output package file - <code>--format &lt;FORMAT&gt;</code> <code>-f</code> Package format: nim, docker, helm <code>nim</code> <code>--registry &lt;URL&gt;</code> Container registry URL - <code>--tag &lt;TAG&gt;</code> <code>-t</code> Image tag <code>latest</code> <code>--gpu</code> Include GPU support <code>false</code> <code>--triton</code> Package for Triton Inference Server <code>false</code>"},{"location":"cli-reference/#package-formats","title":"Package Formats","text":"<p>NIM (NVIDIA Inference Microservice): <pre><code>portalis package --input model.wasm --format nim --output model.nim --gpu\n</code></pre></p> <p>Docker Container: <pre><code>portalis package -i app.wasm -f docker -o app:v1.0 --registry docker.io/myorg\n</code></pre></p> <p>Helm Chart: <pre><code>portalis package -i service.wasm -f helm -o mychart/ --gpu\n</code></pre></p>"},{"location":"cli-reference/#serve-run-translation-service","title":"<code>serve</code> - Run Translation Service","text":"<p>Start HTTP server for translation API.</p> <pre><code>portalis serve [OPTIONS]\n</code></pre>"},{"location":"cli-reference/#options_4","title":"Options","text":"Option Short Description Default <code>--host &lt;IP&gt;</code> <code>-H</code> Bind address <code>0.0.0.0</code> <code>--port &lt;PORT&gt;</code> <code>-p</code> Listen port <code>8080</code> <code>--workers &lt;N&gt;</code> <code>-w</code> Worker processes CPU cores <code>--mode &lt;MODE&gt;</code> <code>-m</code> Default translation mode <code>pattern</code> <code>--gpu</code> Enable GPU acceleration <code>false</code> <code>--max-requests &lt;N&gt;</code> Max concurrent requests <code>100</code> <code>--timeout &lt;SECONDS&gt;</code> Request timeout <code>30</code>"},{"location":"cli-reference/#examples_3","title":"Examples","text":"<pre><code># Start basic server\nportalis serve --port 8080\n\n# Production server with GPU\nportalis serve --host 0.0.0.0 --port 80 --workers 4 --gpu --mode nemo\n\n# Development server\nportalis serve --port 3000 --mode pattern\n</code></pre>"},{"location":"cli-reference/#api-endpoints","title":"API Endpoints","text":"<p>POST /api/v1/translate: <pre><code>curl -X POST http://localhost:8080/api/v1/translate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"python_code\": \"def add(a: int, b: int) -&gt; int:\\n    return a + b\",\n    \"mode\": \"nemo\",\n    \"temperature\": 0.2\n  }'\n</code></pre></p> <p>Response: <pre><code>{\n  \"rust_code\": \"pub fn add(a: i64, b: i64) -&gt; i64 {\\n    a + b\\n}\",\n  \"wasm_bytes\": \"&lt;base64-encoded&gt;\",\n  \"confidence\": 0.98,\n  \"metrics\": {\n    \"total_time_ms\": 145.2,\n    \"gpu_utilization\": 0.85\n  }\n}\n</code></pre></p>"},{"location":"cli-reference/#doctor-system-diagnostics","title":"<code>doctor</code> - System Diagnostics","text":"<p>Check installation and dependencies.</p> <pre><code>portalis doctor [OPTIONS]\n</code></pre>"},{"location":"cli-reference/#options_5","title":"Options","text":"Option Description Default <code>--verbose</code> Show detailed diagnostics <code>false</code> <code>--fix</code> Attempt to fix issues <code>false</code>"},{"location":"cli-reference/#example-output","title":"Example Output","text":"<pre><code>Portalis System Diagnostics\n============================\n\n\u2705 Rust compiler: 1.75.0\n\u2705 Cargo: 1.75.0\n\u2705 WASM target (wasm32-wasi): installed\n\u2705 Core platform: operational\n\nGPU Acceleration:\n\u26a0\ufe0f  CUDA: not detected (optional)\n\u26a0\ufe0f  NeMo service: not running (optional)\n   Start with: docker-compose up nemo-service\n\nDeployment:\n\u2705 Docker: 24.0.7\n\u2705 Kubernetes: kubectl 1.28.0\n\u26a0\ufe0f  Helm: not installed (optional)\n\nStatus: Ready for CPU-based translation\nRecommendation: Install GPU for 2-3x performance improvement\n</code></pre>"},{"location":"cli-reference/#version-version-information","title":"<code>version</code> - Version Information","text":"<p>Show version and build information.</p> <pre><code>portalis version [OPTIONS]\n</code></pre>"},{"location":"cli-reference/#options_6","title":"Options","text":"Option Description <code>--json</code> Output as JSON <code>--check-updates</code> Check for newer versions"},{"location":"cli-reference/#example-output_1","title":"Example Output","text":"<pre><code>Portalis v0.1.0\nPython \u2192 Rust \u2192 WASM Translation Platform\n\nBuild Information:\n  Commit: 453a9d02\n  Date: 2025-10-03\n  Features: nemo, cuda, triton\n\nComponents:\n  Core: 6,550 LOC\n  NVIDIA Stack: 35,000+ LOC\n  Tests: 104 passing\n\nNVIDIA Integration:\n  \u2705 NeMo: GPU translation service\n  \u2705 CUDA: AST parsing acceleration\n  \u2705 Triton: Model serving\n  \u2705 NIM: Microservice packaging\n  \u2705 DGX Cloud: Distributed orchestration\n  \u2705 Omniverse: WASM runtime (62 FPS)\n\nDocumentation: https://docs.portalis.dev\n</code></pre>"},{"location":"cli-reference/#configuration-file","title":"Configuration File","text":""},{"location":"cli-reference/#portalistoml","title":"portalis.toml","text":"<p>Full configuration file example:</p> <pre><code># Portalis Configuration File\n\n[translation]\n# Default translation mode\nmode = \"nemo\"                    # \"pattern\" or \"nemo\"\ntemperature = 0.2                # 0.0 (deterministic) to 1.0 (creative)\ninclude_metrics = true           # Collect performance metrics\nrun_tests = true                 # Run conformance tests\n\n[optimization]\n# WASM optimization settings\nopt_level = 3                    # 0, 1, 2, 3, 's' (size), 'z' (aggressive size)\nstrip_debug = true               # Remove debug symbols\nlto = true                       # Link-time optimization\n\n[gpu]\n# GPU acceleration settings\nenabled = true                   # Enable GPU features\ncuda_device = 0                  # CUDA device ID (0-7)\nbatch_size = 32                  # GPU batch size\nmemory_limit_mb = 8192           # GPU memory limit\n\n[services]\n# External service URLs\nnemo_url = \"http://localhost:8000\"\ntriton_url = \"http://localhost:8001\"\ndgx_cloud_url = \"https://api.dgx-cloud.nvidia.com\"\n\n[services.nemo]\n# NeMo-specific configuration\ntimeout_seconds = 30\nretry_attempts = 3\nretry_delay_ms = 1000\n\n[output]\n# Output settings\nwasm_dir = \"./dist/wasm\"\nrust_dir = \"./dist/rust\"\npreserve_rust = false            # Keep intermediate Rust files\npreserve_artifacts = true        # Keep build artifacts\n\n[logging]\n# Logging configuration\nlevel = \"info\"                   # trace, debug, info, warn, error\nformat = \"pretty\"                # pretty, json, compact\noutput = \"stdout\"                # stdout, stderr, file\nfile = \"./portalis.log\"          # Log file (if output=file)\n\n[cache]\n# Caching settings\nenabled = true\ndirectory = \"~/.cache/portalis\"\nmax_size_mb = 1024\nttl_seconds = 86400              # 24 hours\n\n[performance]\n# Performance tuning\nparallel_workers = 4             # Number of parallel workers\nmax_concurrent_requests = 100\nrequest_timeout_seconds = 30\n</code></pre>"},{"location":"cli-reference/#examples-by-use-case","title":"Examples by Use Case","text":""},{"location":"cli-reference/#development","title":"Development","text":"<pre><code># Fast iteration\nportalis translate -i app.py --mode pattern --no-tests\n\n# Auto-rebuild on changes (with cargo-watch)\ncargo watch -x \"portalis translate -i app.py\"\n</code></pre>"},{"location":"cli-reference/#testing","title":"Testing","text":"<pre><code># Comprehensive testing\nportalis test -i app.py --coverage --benchmark\n\n# CI/CD pipeline\nportalis batch -i ./src -o ./dist --fail-fast\n</code></pre>"},{"location":"cli-reference/#production","title":"Production","text":"<pre><code># High-quality translation\nportalis translate -i service.py --mode nemo -O z --strip-debug\n\n# Package for Kubernetes\nportalis package -i service.wasm -f helm --gpu\n</code></pre>"},{"location":"cli-reference/#debugging","title":"Debugging","text":"<pre><code># Verbose logging\nRUST_LOG=debug portalis translate -i debug.py --show-rust\n\n# With backtrace\nRUST_BACKTRACE=1 portalis translate -i error.py\n</code></pre>"},{"location":"cli-reference/#shell-completion","title":"Shell Completion","text":"<p>Generate shell completion scripts:</p> <pre><code># Bash\nportalis completion bash &gt; /etc/bash_completion.d/portalis\n\n# Zsh\nportalis completion zsh &gt; /usr/local/share/zsh/site-functions/_portalis\n\n# Fish\nportalis completion fish &gt; ~/.config/fish/completions/portalis.fish\n\n# PowerShell\nportalis completion powershell &gt; $PROFILE\n</code></pre>"},{"location":"cli-reference/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Python Compatibility Matrix</li> <li>Troubleshooting Guide</li> <li>Performance Tuning</li> <li>API Reference</li> </ul>"},{"location":"compliance/","title":"Compliance Guide","text":"<p>Compliance considerations for enterprise deployment of Portalis.</p>"},{"location":"compliance/#overview","title":"Overview","text":"<p>Portalis is designed with enterprise compliance requirements in mind, supporting SOC2, GDPR, and other regulatory frameworks.</p>"},{"location":"compliance/#soc2-compliance","title":"SOC2 Compliance","text":""},{"location":"compliance/#security-principles","title":"Security Principles","text":"<p>CC6.1 - Logical Access Controls: - API key authentication - Role-based access control (RBAC) - Multi-factor authentication (MFA) support</p> <p>CC6.6 - Encryption: - TLS 1.3 for data in transit - AES-256 for data at rest - Key management via HashiCorp Vault</p> <p>CC7.2 - System Monitoring: - Comprehensive logging (Prometheus + Grafana) - Real-time alerting - Audit trail for all operations</p> <p>CC7.4 - Change Management: - Automated CI/CD with approval gates - Version control (Git) - Rollback procedures</p>"},{"location":"compliance/#audit-logging","title":"Audit Logging","text":"<p>All security-relevant events are logged:</p> <pre><code>{\n  \"timestamp\": \"2025-10-03T12:34:56Z\",\n  \"event_type\": \"translation.request\",\n  \"user_id\": \"user-123\",\n  \"api_key_id\": \"key-456\",\n  \"source_ip\": \"192.168.1.1\",\n  \"resource\": \"fibonacci.py\",\n  \"action\": \"translate\",\n  \"result\": \"success\",\n  \"duration_ms\": 315\n}\n</code></pre> <p>Retention: 90 days minimum, configurable up to 7 years</p>"},{"location":"compliance/#evidence-collection","title":"Evidence Collection","text":"<p>For SOC2 audits, Portalis provides:</p> <ol> <li>Access Logs: All authentication attempts</li> <li>Change Logs: All code deployments</li> <li>Security Scans: Weekly Trivy scans</li> <li>Incident Reports: Security incident documentation</li> <li>Training Records: Security awareness training</li> </ol>"},{"location":"compliance/#gdpr-compliance","title":"GDPR Compliance","text":""},{"location":"compliance/#data-protection-principles","title":"Data Protection Principles","text":"<p>Article 5 - Lawfulness, Fairness, Transparency: - Clear privacy policy - Explicit consent for data collection - Transparent data processing</p> <p>Article 25 - Privacy by Design: - Minimal data collection - Pseudonymization where possible - Data minimization by default</p> <p>Article 32 - Security: - Encryption at rest and in transit - Regular security testing - Incident response procedures</p>"},{"location":"compliance/#data-subject-rights","title":"Data Subject Rights","text":"<p>Right to Access (Article 15): <pre><code># Export user data\nportalis admin export-user-data --user-id &lt;id&gt; --format json\n</code></pre></p> <p>Right to Erasure (Article 17): <pre><code># Delete user data\nportalis admin delete-user-data --user-id &lt;id&gt; --confirm\n</code></pre></p> <p>Right to Data Portability (Article 20): - Export in JSON format - Machine-readable - Standard schemas</p>"},{"location":"compliance/#data-processing-agreement-dpa","title":"Data Processing Agreement (DPA)","text":"<p>Available upon request for enterprise customers.</p> <p>Contact: legal@portalis.dev</p>"},{"location":"compliance/#data-handling","title":"Data Handling","text":""},{"location":"compliance/#data-classification","title":"Data Classification","text":"Classification Examples Handling Public Documentation, marketing No restrictions Internal Logs, metrics Access controlled Confidential API keys, customer code Encrypted Restricted Personal data, secrets Strict access control"},{"location":"compliance/#data-retention","title":"Data Retention","text":"Data Type Retention Period Purpose Translation requests 30 days Service delivery Audit logs 90 days (SOC2: 1 year) Security auditing User accounts Until deletion Service provision Backups 30 days Disaster recovery"},{"location":"compliance/#data-deletion","title":"Data Deletion","text":"<p>Automated deletion: - Translation data: 30 days - Cache data: 24 hours - Temporary files: Immediate</p> <p>User-initiated deletion: - Account deletion: Immediate - Data export before deletion: Available</p>"},{"location":"compliance/#compliance-certifications","title":"Compliance Certifications","text":""},{"location":"compliance/#current-status","title":"Current Status","text":"<p>In Progress: - [ ] SOC2 Type I (Q1 2026) - [ ] SOC2 Type II (Q3 2026) - [ ] GDPR compliance audit (Q2 2026)</p> <p>Planned: - [ ] ISO 27001 (2026) - [ ] HIPAA compliance (2027, healthcare customers)</p>"},{"location":"compliance/#compliance-roadmap","title":"Compliance Roadmap","text":"<p>2026 Q1: - Complete SOC2 Type I certification - GDPR compliance audit - Privacy impact assessment</p> <p>2026 Q2: - SOC2 Type II observation period begins - ISO 27001 preparation</p> <p>2026 Q3: - SOC2 Type II certification - Regular compliance audits</p>"},{"location":"compliance/#regional-compliance","title":"Regional Compliance","text":""},{"location":"compliance/#us-compliance","title":"US Compliance","text":"<p>Data Residency: - US customer data stored in US region (AWS us-east-1) - No data transfer outside US without consent</p> <p>Frameworks: - SOC2 Type II - NIST Cybersecurity Framework - FedRAMP (roadmap)</p>"},{"location":"compliance/#eu-compliance","title":"EU Compliance","text":"<p>Data Residency: - EU customer data stored in EU region (AWS eu-west-1) - GDPR-compliant data processing</p> <p>Privacy Shield Replacement: - Standard Contractual Clauses (SCCs) - EU representative appointed</p>"},{"location":"compliance/#uk-compliance","title":"UK Compliance","text":"<p>Post-Brexit: - UK GDPR compliance - UK representative appointed - Data adequacy provisions</p>"},{"location":"compliance/#incident-response","title":"Incident Response","text":""},{"location":"compliance/#security-incident-procedure","title":"Security Incident Procedure","text":"<ol> <li>Detection: Automated monitoring + manual reporting</li> <li>Containment: Isolate affected systems</li> <li>Investigation: Root cause analysis</li> <li>Remediation: Fix vulnerabilities</li> <li>Notification: Notify affected parties (72 hours for GDPR)</li> <li>Documentation: Incident report</li> </ol>"},{"location":"compliance/#breach-notification","title":"Breach Notification","text":"<p>GDPR Article 33: - Notification to supervisory authority within 72 hours - Notification to data subjects if high risk</p> <p>Contact: security@portalis.dev</p>"},{"location":"compliance/#vendor-management","title":"Vendor Management","text":""},{"location":"compliance/#subprocessors","title":"Subprocessors","text":"Vendor Purpose Location Compliance AWS Cloud hosting US/EU SOC2, ISO 27001 NVIDIA GPU infrastructure US SOC2 Prometheus Monitoring Self-hosted N/A"},{"location":"compliance/#due-diligence","title":"Due Diligence","text":"<p>All vendors undergo: - Security questionnaire - Compliance verification - Contract review - Annual re-assessment</p>"},{"location":"compliance/#privacy-policy","title":"Privacy Policy","text":"<p>Key Points: - What data we collect - How we use data - Data retention periods - User rights - Contact information</p> <p>Full policy: https://portalis.dev/privacy</p>"},{"location":"compliance/#terms-of-service","title":"Terms of Service","text":"<p>Key Sections: - Service description - User obligations - Data usage - Liability limitations - Dispute resolution</p> <p>Full terms: https://portalis.dev/terms</p>"},{"location":"compliance/#compliance-resources","title":"Compliance Resources","text":""},{"location":"compliance/#documentation","title":"Documentation","text":"<ul> <li>Privacy Policy: https://portalis.dev/privacy</li> <li>Terms of Service: https://portalis.dev/terms</li> <li>DPA Template: Available on request</li> <li>Security Whitepaper: https://portalis.dev/security</li> </ul>"},{"location":"compliance/#support","title":"Support","text":"<ul> <li>Compliance Questions: compliance@portalis.dev</li> <li>Security Issues: security@portalis.dev</li> <li>Privacy Concerns: privacy@portalis.dev</li> <li>Legal Inquiries: legal@portalis.dev</li> </ul>"},{"location":"compliance/#see-also","title":"See Also","text":"<ul> <li>Security Guide</li> <li>Deployment Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"getting-started/","title":"Getting Started with Portalis","text":"<p>Welcome to Portalis, the GPU-accelerated Python to Rust to WASM translation platform. This guide will help you get up and running quickly.</p>"},{"location":"getting-started/#what-is-portalis","title":"What is Portalis?","text":"<p>Portalis automatically translates Python code to high-performance Rust code and compiles it to WASM (WebAssembly), providing:</p> <ul> <li>2-3x Performance Improvement: GPU-accelerated translation using NVIDIA NeMo</li> <li>High-Quality Code: AI-powered translation with 98.5% success rate</li> <li>Real-time Execution: 62 FPS WASM runtime in NVIDIA Omniverse</li> <li>Enterprise-Ready: Production-tested with 104 passing tests</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before installing Portalis, ensure you have:</p> <ul> <li>Rust 1.75+: Install Rust</li> <li>Python 3.11+: For input Python code</li> <li>Docker (optional): For containerized deployment</li> <li>NVIDIA GPU (optional): For GPU acceleration (CUDA 12.0+)</li> </ul>"},{"location":"getting-started/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/#method-1-cargo-install-recommended","title":"Method 1: Cargo Install (Recommended)","text":"<pre><code># Install from crates.io\ncargo install portalis\n\n# Verify installation\nportalis version\n</code></pre>"},{"location":"getting-started/#method-2-pre-built-binaries","title":"Method 2: Pre-built Binaries","text":"<p>Download pre-built binaries from our releases page:</p> <pre><code># Linux (x86_64)\nwget https://github.com/portalis/portalis/releases/latest/download/portalis-linux-x86_64.tar.gz\ntar xzf portalis-linux-x86_64.tar.gz\nsudo mv portalis /usr/local/bin/\n\n# macOS (Apple Silicon)\nwget https://github.com/portalis/portalis/releases/latest/download/portalis-macos-aarch64.tar.gz\ntar xzf portalis-macos-aarch64.tar.gz\nsudo mv portalis /usr/local/bin/\n\n# Windows\n# Download portalis-windows-x86_64.zip and extract to PATH\n</code></pre>"},{"location":"getting-started/#method-3-build-from-source","title":"Method 3: Build from Source","text":"<pre><code># Clone repository\ngit clone https://github.com/portalis/portalis.git\ncd portalis\n\n# Build with all features (requires GPU)\ncargo build --release --all-features\n\n# Or build CPU-only version\ncargo build --release\n\n# Install locally\ncargo install --path ./cli\n</code></pre>"},{"location":"getting-started/#method-4-docker","title":"Method 4: Docker","text":"<pre><code># Pull official image\ndocker pull portalis/portalis:latest\n\n# Run container\ndocker run -it --rm portalis/portalis:latest portalis version\n\n# With GPU support\ndocker run -it --rm --gpus all portalis/portalis:gpu portalis version\n</code></pre>"},{"location":"getting-started/#quick-start-tutorial","title":"Quick Start Tutorial","text":""},{"location":"getting-started/#hello-world-translation","title":"Hello World Translation","text":"<p>Let's translate your first Python file to WASM!</p> <p>Step 1: Create a simple Python file (<code>hello.py</code>):</p> <pre><code>def greet(name: str) -&gt; str:\n    \"\"\"Greet someone by name.\"\"\"\n    return f\"Hello, {name}!\"\n\ndef main():\n    message = greet(\"World\")\n    print(message)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Step 2: Translate to WASM:</p> <pre><code>portalis translate --input hello.py --output hello.wasm\n</code></pre> <p>Output: <pre><code>\ud83d\udd04 Translating \"hello.py\"\n\u2705 Translation complete!\n   Rust code: 23 lines\n   WASM size: 8,432 bytes\n   Tests: 3 passed, 0 failed\n   Output: \"hello.wasm\"\n</code></pre></p> <p>Step 3: View the generated Rust code:</p> <pre><code>portalis translate --input hello.py --show-rust\n</code></pre> <p>Generated Rust: <pre><code>pub fn greet(name: &amp;str) -&gt; String {\n    format!(\"Hello, {}!\", name)\n}\n\npub fn main() {\n    let message = greet(\"World\");\n    println!(\"{}\", message);\n}\n</code></pre></p>"},{"location":"getting-started/#more-complex-example","title":"More Complex Example","text":"<p>Let's try a more realistic example with type hints and data structures:</p> <p>calculator.py: <pre><code>from typing import List\n\nclass Calculator:\n    def __init__(self, precision: int = 2):\n        self.precision = precision\n\n    def add(self, a: float, b: float) -&gt; float:\n        \"\"\"Add two numbers.\"\"\"\n        return round(a + b, self.precision)\n\n    def sum_list(self, numbers: List[float]) -&gt; float:\n        \"\"\"Sum a list of numbers.\"\"\"\n        total = 0.0\n        for num in numbers:\n            total += num\n        return round(total, self.precision)\n\n# Usage\ncalc = Calculator(precision=3)\nresult = calc.add(10.5, 20.3)\nprint(f\"Result: {result}\")\n</code></pre></p> <p>Translate: <pre><code>portalis translate --input calculator.py --output calculator.wasm --show-rust\n</code></pre></p>"},{"location":"getting-started/#basic-cli-usage","title":"Basic CLI Usage","text":""},{"location":"getting-started/#common-commands","title":"Common Commands","text":"<pre><code># Translate a single file\nportalis translate --input myfile.py --output myfile.wasm\n\n# Translate with verbose logging\nRUST_LOG=debug portalis translate --input myfile.py\n\n# Show generated Rust code\nportalis translate --input myfile.py --show-rust\n\n# Translate multiple files (batch mode)\nportalis batch --input-dir ./src --output-dir ./dist\n\n# Check version\nportalis version\n\n# Show help\nportalis --help\n</code></pre>"},{"location":"getting-started/#configuration-file","title":"Configuration File","text":"<p>Create a <code>portalis.toml</code> configuration file for project-specific settings:</p> <pre><code># portalis.toml\n\n[translation]\n# Translation mode: \"pattern\" (fast) or \"nemo\" (high-quality, requires GPU)\nmode = \"nemo\"\ntemperature = 0.2\ninclude_metrics = true\n\n[optimization]\n# Optimization level for WASM output\nopt_level = 3\nstrip_debug = true\n\n[gpu]\n# Enable GPU acceleration\nenabled = true\ncuda_device = 0\n\n[output]\n# Output directory\nwasm_dir = \"./dist/wasm\"\nrust_dir = \"./dist/rust\"\npreserve_rust = true\n</code></pre> <p>Use configuration file: <pre><code>portalis translate --input myfile.py --config portalis.toml\n</code></pre></p>"},{"location":"getting-started/#common-workflows","title":"Common Workflows","text":""},{"location":"getting-started/#workflow-1-development-fast-iteration","title":"Workflow 1: Development (Fast Iteration)","text":"<pre><code># Use pattern-based translation for quick feedback\nportalis translate --input myfile.py --mode pattern\n\n# Auto-rebuild on file changes (using cargo-watch)\ncargo watch -x \"portalis translate --input myfile.py\"\n</code></pre>"},{"location":"getting-started/#workflow-2-production-high-quality","title":"Workflow 2: Production (High Quality)","text":"<pre><code># Use NeMo translation for production code\nportalis translate --input myfile.py --mode nemo --opt-level 3\n\n# Verify with tests\nportalis test --input myfile.py\n\n# Package for deployment\nportalis package --input myfile.wasm --output myfile.nim\n</code></pre>"},{"location":"getting-started/#workflow-3-batch-translation","title":"Workflow 3: Batch Translation","text":"<pre><code># Translate entire project\nportalis batch \\\n  --input-dir ./src/python \\\n  --output-dir ./dist/wasm \\\n  --parallel 4 \\\n  --mode nemo\n</code></pre>"},{"location":"getting-started/#workflow-4-cicd-integration","title":"Workflow 4: CI/CD Integration","text":"<pre><code># .github/workflows/translate.yml\nname: Translate Python to WASM\n\non: [push]\n\njobs:\n  translate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install Portalis\n        run: cargo install portalis\n\n      - name: Translate Python files\n        run: |\n          portalis batch \\\n            --input-dir ./src \\\n            --output-dir ./dist \\\n            --mode pattern\n\n      - name: Upload WASM artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: wasm-files\n          path: ./dist/*.wasm\n</code></pre>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"<p>Configure Portalis behavior with environment variables:</p> <pre><code># Logging level\nexport RUST_LOG=info          # debug, info, warn, error\n\n# NeMo service URL (if using remote NeMo)\nexport NEMO_SERVICE_URL=http://localhost:8000\n\n# CUDA device selection\nexport CUDA_VISIBLE_DEVICES=0\n\n# Performance tuning\nexport PORTALIS_BATCH_SIZE=32\nexport PORTALIS_WORKERS=4\n</code></pre>"},{"location":"getting-started/#verification","title":"Verification","text":"<p>Verify your installation is working correctly:</p> <pre><code># Run self-test\nportalis doctor\n\n# Expected output:\n# \u2705 Rust compiler: 1.75.0\n# \u2705 WASM target: installed\n# \u2705 Core platform: operational\n# \u26a0\ufe0f  GPU acceleration: not available (optional)\n# \u26a0\ufe0f  NeMo service: not running (optional)\n</code></pre>"},{"location":"getting-started/#performance-tips","title":"Performance Tips","text":""},{"location":"getting-started/#cpu-only-mode","title":"CPU-Only Mode","text":"<ul> <li>Use <code>--mode pattern</code> for fastest translation</li> <li>Expect ~366,000 translations/sec for simple functions</li> <li>Suitable for development and CI/CD</li> </ul>"},{"location":"getting-started/#gpu-accelerated-mode","title":"GPU-Accelerated Mode","text":"<ul> <li>Use <code>--mode nemo</code> for highest quality</li> <li>Requires NVIDIA GPU with CUDA 12.0+</li> <li>2-3x faster than traditional transpilers</li> <li>Best for production code</li> </ul>"},{"location":"getting-started/#batch-processing","title":"Batch Processing","text":"<ul> <li>Use <code>portalis batch</code> for multiple files</li> <li>Enable parallelism with <code>--parallel N</code></li> <li>GPU automatically batches requests (up to 32)</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have Portalis installed and working:</p> <ol> <li>Learn the CLI: Read the CLI Reference for all available commands</li> <li>Check Compatibility: Review Python Compatibility Matrix to understand supported features</li> <li>Explore Architecture: Understand how Portalis works in Architecture Overview</li> <li>Deploy to Production: See Deployment Guides for Kubernetes/Docker</li> <li>Optimize Performance: Read Performance Tuning Guide for best practices</li> <li>Troubleshoot Issues: Reference Troubleshooting Guide for common problems</li> </ol>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: https://docs.portalis.dev</li> <li>GitHub Issues: https://github.com/portalis/portalis/issues</li> <li>Discord Community: https://discord.gg/portalis</li> <li>Email Support: support@portalis.dev</li> </ul>"},{"location":"getting-started/#example-projects","title":"Example Projects","text":"<p>Explore real-world examples:</p> <pre><code># Clone examples repository\ngit clone https://github.com/portalis/portalis-examples.git\ncd portalis-examples\n\n# Run examples\ncd fibonacci\nportalis translate --input fibonacci.py --show-rust\n\ncd ../physics-simulation\nportalis translate --input projectile.py --output projectile.wasm\n</code></pre>"},{"location":"getting-started/#whats-next","title":"What's Next?","text":"<p>Portalis is production-ready with comprehensive NVIDIA stack integration:</p> <ul> <li>NeMo Translation: AI-powered code generation</li> <li>CUDA Acceleration: 10-37x faster AST parsing</li> <li>Triton Serving: Scalable model deployment</li> <li>DGX Cloud: Distributed GPU orchestration</li> <li>Omniverse Runtime: Real-time WASM execution at 62 FPS</li> </ul> <p>Ready to dive deeper? Continue to the CLI Reference to master all available commands.</p>"},{"location":"monitoring/","title":"Portalis Monitoring and Observability Guide","text":"<p>Week 33 - Phase 4: Production Monitoring Implementation</p>"},{"location":"monitoring/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Architecture</li> <li>Metrics Reference</li> <li>Dashboards</li> <li>Alert Rules</li> <li>Health Checks</li> <li>Logging</li> <li>Distributed Tracing</li> <li>Troubleshooting</li> <li>SLO/SLA Definitions</li> <li>Runbooks</li> </ol>"},{"location":"monitoring/#overview","title":"Overview","text":"<p>Portalis monitoring provides comprehensive observability across all system components with:</p> <ul> <li>Metrics: Prometheus exporters for all services</li> <li>Dashboards: Grafana dashboards for visualization</li> <li>Alerts: Intelligent alerting with runbooks</li> <li>Health Checks: Liveness and readiness probes</li> <li>Logging: Structured JSON logging</li> <li>Tracing: OpenTelemetry distributed tracing</li> </ul>"},{"location":"monitoring/#key-metrics","title":"Key Metrics","text":"<ul> <li>Translation success rate (target: &gt;95%)</li> <li>P95 latency (target: &lt;5s)</li> <li>Throughput (target: &gt;100 QPS)</li> <li>Error rates by category</li> <li>Resource utilization (CPU, Memory, GPU)</li> <li>WASM compilation and execution metrics</li> </ul>"},{"location":"monitoring/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Portalis   \u2502\n\u2502   Services  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n      \u2502 Metrics Export\n      \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Prometheus  \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Server    \u2502      \u2502 Scrape\n\u2514\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n      \u2502              \u2502\n      \u2502 PromQL       \u2502\n      \u25bc              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n\u2502   Grafana   \u2502      \u2502\n\u2502  Dashboards \u2502      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502\n\u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 AlertManager\u2502\n\u2502   &amp; Alerts  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Application \u2502\n\u2502    Logs     \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Structured JSON\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Traces    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 Jaeger/Zipkin\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"monitoring/#metrics-reference","title":"Metrics Reference","text":""},{"location":"monitoring/#translation-metrics","title":"Translation Metrics","text":"Metric Type Description Labels <code>portalis_translations_total</code> Counter Total translation attempts source_language, target_format <code>portalis_translations_success_total</code> Counter Successful translations source_language, target_format <code>portalis_translations_failed_total</code> Counter Failed translations source_language, target_format, error_category <code>portalis_translation_duration_seconds</code> Histogram Translation duration source_language, complexity_level <code>portalis_translation_lines_of_code</code> Histogram Lines of code translated source_language <code>portalis_translation_complexity_score</code> Gauge Cyclomatic complexity translation_id, source_language <code>portalis_translation_success_rate</code> Gauge Success rate percentage source_language, target_format <code>portalis_translations_in_progress</code> Gauge Active translations source_language"},{"location":"monitoring/#agent-metrics","title":"Agent Metrics","text":"Metric Type Description Labels <code>portalis_agent_executions_total</code> Counter Agent executions agent_name, agent_type <code>portalis_agent_execution_duration_seconds</code> Histogram Agent duration agent_name, agent_type <code>portalis_agent_status_total</code> Counter Agent status counts agent_name, status <code>portalis_agent_memory_bytes</code> Gauge Agent memory usage agent_name <code>portalis_agent_cpu_percent</code> Gauge Agent CPU usage agent_name <code>portalis_agents_active</code> Gauge Active agents agent_type"},{"location":"monitoring/#pipeline-metrics","title":"Pipeline Metrics","text":"Metric Type Description Labels <code>portalis_pipeline_phase_duration_seconds</code> Histogram Phase duration phase_name <code>portalis_pipeline_phase_status_total</code> Counter Phase status phase_name, status <code>portalis_pipeline_duration_seconds</code> Histogram End-to-end duration pipeline_type <code>portalis_pipelines_active</code> Gauge Active pipelines - <code>portalis_pipeline_queue_depth</code> Gauge Queue depth priority"},{"location":"monitoring/#wasm-metrics","title":"WASM Metrics","text":"Metric Type Description Labels <code>portalis_wasm_compile_duration_seconds</code> Histogram Compilation time optimization_level <code>portalis_wasm_binary_size_bytes</code> Histogram Binary size optimization_level <code>portalis_wasm_optimization_level</code> Gauge Optimization level (0-3) module_id <code>portalis_wasm_execution_duration_seconds</code> Histogram Execution time module_name <code>portalis_wasm_memory_bytes</code> Gauge Memory usage module_name <code>portalis_wasm_modules_total</code> Counter Modules created -"},{"location":"monitoring/#error-metrics","title":"Error Metrics","text":"Metric Type Description Labels <code>portalis_errors_total</code> Counter Total errors category, severity, component <code>portalis_parse_errors_total</code> Counter Parse errors error_type, source_language <code>portalis_translation_errors_total</code> Counter Translation errors error_type, phase <code>portalis_compilation_errors_total</code> Counter Compilation errors error_type, target_format <code>portalis_runtime_errors_total</code> Counter Runtime errors error_type, component <code>portalis_error_recoveries_total</code> Counter Error recoveries error_category, recovery_method"},{"location":"monitoring/#cache-metrics","title":"Cache Metrics","text":"Metric Type Description Labels <code>portalis_cache_hits_total</code> Counter Cache hits cache_name, cache_type <code>portalis_cache_misses_total</code> Counter Cache misses cache_name, cache_type <code>portalis_cache_evictions_total</code> Counter Cache evictions cache_name, reason <code>portalis_cache_size_bytes</code> Gauge Cache size cache_name <code>portalis_cache_entries</code> Gauge Entry count cache_name <code>portalis_cache_hit_rate</code> Gauge Hit rate % cache_name"},{"location":"monitoring/#system-metrics","title":"System Metrics","text":"Metric Type Description Labels <code>portalis_cpu_usage_percent</code> Gauge CPU usage - <code>portalis_memory_usage_bytes</code> Gauge Memory usage - <code>portalis_disk_usage_bytes</code> Gauge Disk usage mount_point <code>portalis_network_io_bytes_total</code> Counter Network I/O direction, interface <code>portalis_process_count</code> Gauge Process count - <code>portalis_uptime_seconds_total</code> Counter Uptime -"},{"location":"monitoring/#dashboards","title":"Dashboards","text":""},{"location":"monitoring/#1-portalis-overview-dashboard","title":"1. Portalis Overview Dashboard","text":"<p>File: <code>monitoring/grafana/portalis-overview.json</code></p> <p>Panels: - System Health (success rate, active pipelines, error rate) - Translation Rate (by source language) - Success vs Failure rates - Agent Performance (execution duration by agent) - Active Agents by Type - Resource Utilization (CPU, Memory, Cache) - WASM Performance (compilation time, binary size)</p> <p>URL: <code>http://grafana:3000/d/portalis-overview</code></p>"},{"location":"monitoring/#2-portalis-performance-dashboard","title":"2. Portalis Performance Dashboard","text":"<p>File: <code>monitoring/grafana/portalis-performance.json</code></p> <p>Panels: - Latency Percentiles (P50, P95, P99) - Latency Over Time - Translation Throughput (QPS) - Lines of Code Processed - CPU and Memory Usage - GPU Utilization - WASM Performance Metrics - Pipeline Phase Performance - Comparison vs Baselines</p> <p>URL: <code>http://grafana:3000/d/portalis-performance</code></p>"},{"location":"monitoring/#3-portalis-error-analysis-dashboard","title":"3. Portalis Error Analysis Dashboard","text":"<p>File: <code>monitoring/grafana/portalis-errors.json</code></p> <p>Panels: - Error Rate Overview - Error Rate Over Time - Errors by Category and Severity - Translation Failures by Category - Parse Errors by Type - Errors by Component - Agent Failures - Error Recovery Metrics - Active Alerts - 7-Day Error Trend</p> <p>URL: <code>http://grafana:3000/d/portalis-errors</code></p>"},{"location":"monitoring/#alert-rules","title":"Alert Rules","text":""},{"location":"monitoring/#critical-alerts","title":"Critical Alerts","text":"Alert Condition Duration Action <code>PortalisServiceDown</code> up{job=\"portalis\"} == 0 1m Page on-call engineer <code>PortalisVeryLowSuccessRate</code> Success rate &lt; 80% 2m Page on-call engineer <code>PortalisHighErrorRate</code> Error rate &gt; 10% 5m Page on-call engineer <code>PortalisVerySlowTranslations</code> P95 &gt; 10s 3m Page on-call engineer <code>PortalisGPUOutOfMemory</code> GPU memory &gt; 95% 2m Scale or restart <code>PortalisWASMCompilationFailures</code> WASM failures &gt; 0.1/sec 5m Investigate compiler"},{"location":"monitoring/#warning-alerts","title":"Warning Alerts","text":"Alert Condition Duration Action <code>PortalisSlowTranslations</code> P95 &gt; 5s 5m Investigate performance <code>PortalisLowSuccessRate</code> Success rate &lt; 95% 5m Review errors <code>PortalisHighCPUUsage</code> CPU &gt; 90% 5m Consider scaling <code>PortalisAgentFailures</code> Agent failure rate &gt; 0.05/s 5m Check agent logs <code>PortalisHighGPUMemory</code> GPU memory &gt; 80% 5m Monitor closely"},{"location":"monitoring/#info-alerts","title":"Info Alerts","text":"Alert Condition Duration Action <code>PortalisLowGPUUtilization</code> Avg GPU &lt; 30% 15m Consider scaling down <code>PortalisLowCacheHitRate</code> Hit rate &lt; 30% 15m Optimize caching"},{"location":"monitoring/#health-checks","title":"Health Checks","text":""},{"location":"monitoring/#endpoints","title":"Endpoints","text":"Endpoint Purpose Expected Response <code>GET /health</code> Liveness probe 200 OK if service running <code>GET /health/detailed</code> Detailed health Component status <code>GET /ready</code> Readiness probe 200 OK if ready for traffic <code>GET /metrics</code> Prometheus metrics Metrics in text format"},{"location":"monitoring/#health-response-format","title":"Health Response Format","text":"<pre><code>{\n  \"status\": \"healthy\",\n  \"timestamp\": 1234567890,\n  \"uptime_seconds\": 3600,\n  \"version\": \"1.0.0\",\n  \"components\": [\n    {\n      \"name\": \"core\",\n      \"status\": \"healthy\",\n      \"message\": null,\n      \"last_check\": 1234567890\n    },\n    {\n      \"name\": \"agents\",\n      \"status\": \"healthy\",\n      \"message\": null,\n      \"last_check\": 1234567890\n    }\n  ]\n}\n</code></pre>"},{"location":"monitoring/#readiness-response-format","title":"Readiness Response Format","text":"<pre><code>{\n  \"ready\": true,\n  \"timestamp\": 1234567890,\n  \"checks\": [\n    {\n      \"name\": \"metrics\",\n      \"ready\": true,\n      \"message\": \"Metrics system initialized\"\n    },\n    {\n      \"name\": \"agents\",\n      \"ready\": true,\n      \"message\": \"All agents initialized\"\n    }\n  ]\n}\n</code></pre>"},{"location":"monitoring/#logging","title":"Logging","text":""},{"location":"monitoring/#log-levels","title":"Log Levels","text":"<ul> <li>TRACE: Very detailed debug information</li> <li>DEBUG: Detailed information for debugging</li> <li>INFO: General informational messages</li> <li>WARN: Warning messages (non-critical issues)</li> <li>ERROR: Error messages (failures requiring attention)</li> </ul>"},{"location":"monitoring/#structured-logging","title":"Structured Logging","text":"<p>All logs are emitted in JSON format with consistent fields:</p> <pre><code>{\n  \"timestamp\": \"2025-10-03T23:00:00Z\",\n  \"level\": \"info\",\n  \"message\": \"Translation completed successfully\",\n  \"target\": \"portalis::transpiler\",\n  \"thread_id\": \"12345\",\n  \"file\": \"transpiler.rs\",\n  \"line\": 123,\n  \"fields\": {\n    \"translation_id\": \"abc123\",\n    \"duration_ms\": 1234.5,\n    \"lines_of_code\": 500\n  }\n}\n</code></pre>"},{"location":"monitoring/#logging-helpers","title":"Logging Helpers","text":"<pre><code>use portalis_core::logging::{AgentLogger, PipelineLogger, TranslationLogger};\n\n// Agent logging\nlet logger = AgentLogger::new(\"ingest-agent\");\nlogger.info(\"Starting parse operation\");\nlogger.error(\"Parse failed\", Some(&amp;error_context));\n\n// Pipeline logging\nlet logger = PipelineLogger::new(\"pipeline-123\");\nlogger.phase_start(\"transpile\");\nlogger.phase_complete(\"transpile\", 1234.5);\n\n// Translation logging\nlet logger = TranslationLogger::new(\"trans-456\");\nlogger.start(\"python\", \"wasm\", 500);\nlogger.progress(\"parsing\", 25.0);\nlogger.complete(5000.0, 102400);\n</code></pre>"},{"location":"monitoring/#distributed-tracing","title":"Distributed Tracing","text":""},{"location":"monitoring/#tracing-setup","title":"Tracing Setup","text":"<pre><code>use portalis_core::telemetry::{init_telemetry, TelemetryConfig};\n\nlet config = TelemetryConfig {\n    service_name: \"portalis\".to_string(),\n    enable_jaeger: true,\n    jaeger_endpoint: Some(\"http://jaeger:14268/api/traces\".to_string()),\n    ..Default::default()\n};\n\ninit_telemetry(config)?;\n</code></pre>"},{"location":"monitoring/#creating-spans","title":"Creating Spans","text":"<pre><code>use portalis_core::telemetry::{AgentTracer, PipelineTracer};\nuse tracing::instrument;\n\n// Automatic instrumentation\n#[instrument(skip(self))]\nasync fn execute(&amp;self, input: Input) -&gt; Result&lt;Output&gt; {\n    // Function automatically traced\n}\n\n// Manual span creation\nlet tracer = AgentTracer::new(\"ingest-agent\");\nlet span = tracer.start_span(\"parse_python\");\n// ... do work ...\ntracer.end_span(&amp;span, true, duration_ms);\n</code></pre>"},{"location":"monitoring/#trace-context-propagation","title":"Trace Context Propagation","text":"<pre><code>use portalis_core::telemetry::TraceContext;\n\n// Parent span\nlet parent_context = TraceContext::new();\n\n// Child span\nlet child_context = parent_context.child_span();\n</code></pre>"},{"location":"monitoring/#troubleshooting","title":"Troubleshooting","text":""},{"location":"monitoring/#high-error-rate","title":"High Error Rate","text":"<ol> <li>Check error dashboard for error categories</li> <li>Review logs for specific error messages</li> <li>Check alert annotations for potential causes</li> <li>Verify input data quality</li> <li>Review recent deployments or changes</li> </ol>"},{"location":"monitoring/#slow-translations","title":"Slow Translations","text":"<ol> <li>Check performance dashboard P95/P99 latency</li> <li>Review GPU utilization (should be &gt;60%)</li> <li>Check agent execution times</li> <li>Verify no resource contention (CPU/Memory)</li> <li>Review complexity of input code</li> </ol>"},{"location":"monitoring/#low-success-rate","title":"Low Success Rate","text":"<ol> <li>Check error dashboard for failure categories</li> <li>Common issues:</li> <li>Parse errors: Invalid Python syntax</li> <li>Translation errors: Unsupported constructs</li> <li>Compilation errors: WASM toolchain issues</li> <li>Review error logs for patterns</li> <li>Check input data quality</li> </ol>"},{"location":"monitoring/#gpu-issues","title":"GPU Issues","text":"<ol> <li>Check GPU memory usage</li> <li>Verify GPU temperature (&lt;85\u00b0C)</li> <li>Review CUDA agent logs</li> <li>Check for GPU memory leaks</li> <li>Verify NVIDIA drivers are up to date</li> </ol>"},{"location":"monitoring/#wasm-compilation-failures","title":"WASM Compilation Failures","text":"<ol> <li>Check compilation error metrics</li> <li>Review rustc version compatibility</li> <li>Verify wasm-pack installation</li> <li>Check for disk space issues</li> <li>Review generated Rust code quality</li> </ol>"},{"location":"monitoring/#slosla-definitions","title":"SLO/SLA Definitions","text":""},{"location":"monitoring/#service-level-objectives-slos","title":"Service Level Objectives (SLOs)","text":"Metric Target Measurement Period Availability 99.9% Monthly Translation Success Rate &gt;95% Daily P95 Latency &lt;5 seconds Hourly P99 Latency &lt;10 seconds Hourly Throughput &gt;100 QPS Per minute Error Rate &lt;5% Hourly"},{"location":"monitoring/#service-level-agreements-slas","title":"Service Level Agreements (SLAs)","text":"<p>Tier 1: Critical Production - Availability: 99.9% monthly uptime - P95 Latency: &lt;5s for 95% of requests - Success Rate: &gt;95% of all translations</p> <p>Tier 2: Development/Testing - Availability: 99% monthly uptime - P95 Latency: &lt;10s for 95% of requests - Success Rate: &gt;90% of all translations</p>"},{"location":"monitoring/#error-budget","title":"Error Budget","text":"<ul> <li>Monthly error budget: 0.1% (43.2 minutes of downtime)</li> <li>Budget tracking via <code>portalis:sla:overall_compliance</code> metric</li> <li>Automatic alerting when budget consumed &gt;75%</li> </ul>"},{"location":"monitoring/#runbooks","title":"Runbooks","text":""},{"location":"monitoring/#service-down","title":"Service Down","text":"<p>Alert: <code>PortalisServiceDown</code></p> <ol> <li> <p>Check if service is actually down:    <pre><code>curl http://portalis:8080/health\n</code></pre></p> </li> <li> <p>Check service logs:    <pre><code>kubectl logs -l app=portalis --tail=100\n</code></pre></p> </li> <li> <p>Check recent deployments:    <pre><code>kubectl rollout history deployment/portalis\n</code></pre></p> </li> <li> <p>If crashed, restart:    <pre><code>kubectl rollout restart deployment/portalis\n</code></pre></p> </li> <li> <p>If persists, rollback:    <pre><code>kubectl rollout undo deployment/portalis\n</code></pre></p> </li> </ol>"},{"location":"monitoring/#high-error-rate_1","title":"High Error Rate","text":"<p>Alert: <code>PortalisHighErrorRate</code></p> <ol> <li>Check error dashboard for error breakdown</li> <li>Identify most common error category</li> <li>Review recent code changes</li> <li>Check input data quality</li> <li>If parser errors: Verify Python version compatibility</li> <li>If translation errors: Review unsupported constructs</li> <li>If persistent: Enable debug logging</li> </ol>"},{"location":"monitoring/#slow-performance","title":"Slow Performance","text":"<p>Alert: <code>PortalisSlowTranslations</code></p> <ol> <li>Check GPU utilization (should be &gt;60%)</li> <li>Review agent execution times</li> <li>Check for resource contention</li> <li>Verify no memory leaks</li> <li>Review code complexity of inputs</li> <li>Consider scaling up GPU resources</li> <li>Check cache hit rate</li> </ol>"},{"location":"monitoring/#gpu-out-of-memory","title":"GPU Out of Memory","text":"<p>Alert: <code>PortalisGPUOutOfMemory</code></p> <ol> <li>Identify which GPU is affected</li> <li>Check for memory leaks in CUDA kernels</li> <li>Review batch sizes (reduce if needed)</li> <li>Restart CUDA bridge agent:    <pre><code>kubectl delete pod -l agent=cuda-bridge\n</code></pre></li> <li>If persists: Scale to additional GPUs</li> <li>Monitor memory usage trend</li> </ol>"},{"location":"monitoring/#configuration","title":"Configuration","text":""},{"location":"monitoring/#prometheus-configuration","title":"Prometheus Configuration","text":"<pre><code># prometheus.yml\nscrape_configs:\n  - job_name: 'portalis'\n    scrape_interval: 15s\n    static_configs:\n      - targets: ['portalis:8080']\n    metrics_path: '/metrics'\n</code></pre>"},{"location":"monitoring/#alert-manager-configuration","title":"Alert Manager Configuration","text":"<pre><code># alertmanager.yml\nroute:\n  receiver: 'team-platform'\n  group_by: ['alertname', 'component']\n  group_wait: 30s\n  group_interval: 5m\n  repeat_interval: 4h\n  routes:\n    - match:\n        severity: critical\n      receiver: 'pagerduty'\n    - match:\n        severity: warning\n      receiver: 'slack'\n\nreceivers:\n  - name: 'pagerduty'\n    pagerduty_configs:\n      - service_key: '&lt;key&gt;'\n  - name: 'slack'\n    slack_configs:\n      - api_url: '&lt;webhook&gt;'\n        channel: '#portalis-alerts'\n</code></pre>"},{"location":"monitoring/#environment-variables","title":"Environment Variables","text":"<pre><code># Logging\nexport LOG_LEVEL=info\nexport LOG_JSON=true\n\n# Tracing\nexport ENABLE_JAEGER=true\nexport JAEGER_ENDPOINT=http://jaeger:14268/api/traces\n\n# Metrics\nexport METRICS_PORT=8080\nexport METRICS_PATH=/metrics\n</code></pre>"},{"location":"monitoring/#best-practices","title":"Best Practices","text":"<ol> <li>Monitor proactively: Set up alerts before issues occur</li> <li>Use dashboards: Regularly review system dashboards</li> <li>Structured logging: Always log with context</li> <li>Trace critical paths: Enable tracing for debugging</li> <li>Test alerts: Regularly verify alert firing</li> <li>Document runbooks: Keep troubleshooting steps updated</li> <li>Review metrics: Weekly metric reviews</li> <li>Optimize performance: Use profiling data</li> </ol>"},{"location":"monitoring/#additional-resources","title":"Additional Resources","text":"<ul> <li>Agent Instrumentation Guide</li> <li>Prometheus Documentation</li> <li>Grafana Documentation</li> <li>OpenTelemetry Documentation</li> <li>Phase 3 Monitoring (GPU/DGX)</li> </ul>"},{"location":"onboarding-checklist/","title":"PORTALIS BETA CUSTOMER ONBOARDING CHECKLIST","text":"<p>Version: 1.0 Last Updated: October 2025</p> <p>Welcome to the Portalis Beta Program! This checklist will guide you through the onboarding process to ensure a smooth start with our GPU-accelerated Python-to-Rust-to-WASM translation platform.</p>"},{"location":"onboarding-checklist/#pre-onboarding-before-day-1","title":"Pre-Onboarding (Before Day 1)","text":""},{"location":"onboarding-checklist/#administrative-setup","title":"Administrative Setup","text":"<ul> <li>[ ] Beta Agreement Signed</li> <li>Review and sign Beta Participation Agreement</li> <li>Review and sign NDA (Non-Disclosure Agreement)</li> <li>Complete Terms of Service acceptance</li> <li> <p>Verify authorized signatories</p> </li> <li> <p>[ ] Team Identified</p> </li> <li>Designate technical lead (primary contact)</li> <li>Assign 1-2 integration engineers</li> <li>Identify QA/testing resource</li> <li>Assign executive sponsor</li> <li> <p>Collect team contact information</p> </li> <li> <p>[ ] Communication Channels</p> </li> <li>Provide email addresses for Slack invites</li> <li>Confirm phone numbers for emergency contacts</li> <li>Set up distribution list for announcements</li> <li> <p>Verify time zones for meeting scheduling</p> </li> <li> <p>[ ] Environment Assessment</p> </li> <li>Document current Python codebase details:<ul> <li>Total lines of code</li> <li>Python version(s) in use</li> <li>Key dependencies and frameworks</li> <li>Test coverage percentage</li> </ul> </li> <li>Identify translation pilot project (1K-10K LOC)</li> <li>Confirm infrastructure availability (cloud/on-prem)</li> <li>Check GPU availability (optional but recommended)</li> </ul>"},{"location":"onboarding-checklist/#day-1-account-setup-access","title":"Day 1: Account Setup &amp; Access","text":""},{"location":"onboarding-checklist/#account-provisioning","title":"Account Provisioning","text":"<ul> <li>[ ] Portalis Account Creation</li> <li>Receive account creation email</li> <li>Set up account credentials</li> <li>Configure two-factor authentication (2FA)</li> <li>Verify email address</li> <li> <p>Complete profile setup</p> </li> <li> <p>[ ] Access Verification</p> </li> <li>Log in to Portalis web dashboard: https://app.portalis.ai</li> <li>Access API credentials page</li> <li>Generate API key (save securely)</li> <li>Access documentation portal: https://docs.portalis.ai</li> <li> <p>Bookmark key resources</p> </li> <li> <p>[ ] Team Access</p> </li> <li>Invite team members to organization</li> <li>Assign appropriate roles:<ul> <li>Admin (1-2 people)</li> <li>Developer (engineers)</li> <li>Viewer (stakeholders)</li> </ul> </li> <li>Verify all team members can access platform</li> </ul>"},{"location":"onboarding-checklist/#communication-setup","title":"Communication Setup","text":"<ul> <li>[ ] Slack Workspace</li> <li>Accept Slack invite to portalis-beta.slack.com</li> <li>Join channels:<ul> <li><code>#beta-general</code> (announcements, general discussion)</li> <li><code>#beta-technical</code> (technical support)</li> <li><code>#beta-features</code> (feature requests)</li> <li><code>#beta-performance</code> (optimization discussions)</li> </ul> </li> <li>Introduce your team in <code>#beta-general</code></li> <li> <p>Test direct message with Customer Success Engineer</p> </li> <li> <p>[ ] Support Channels</p> </li> <li>Save beta support email: beta-support@portalis.ai</li> <li>Save emergency hotline: +1 (555) 123-BETA</li> <li>Access GitHub Issues: github.com/portalis/beta-issues</li> <li> <p>Bookmark feedback portal: feedback.portalis.ai</p> </li> <li> <p>[ ] Meeting Scheduling</p> </li> <li>Schedule recurring weekly check-in (30 min)</li> <li>Add to calendar: Engineering Office Hours (Fridays 2-3 PM PT)</li> <li>Schedule initial onboarding session (2 hours)</li> <li>Confirm monthly retrospective time slot</li> </ul>"},{"location":"onboarding-checklist/#week-1-installation-first-translation","title":"Week 1: Installation &amp; First Translation","text":""},{"location":"onboarding-checklist/#environment-setup","title":"Environment Setup","text":"<ul> <li> <p>[ ] CLI Installation <pre><code># Install Portalis CLI\npip install portalis-cli\n\n# Verify installation\nportalis --version\n\n# Configure with API key\nportalis configure --api-key &lt;your-key&gt;\n\n# Test connection\nportalis auth test\n</code></pre></p> </li> <li> <p>[ ] Docker Setup (Optional) <pre><code># Pull Portalis Docker image\ndocker pull portalis/translator:beta\n\n# Verify image\ndocker run portalis/translator:beta --version\n\n# Test container\ndocker run -v $(pwd):/workspace portalis/translator:beta translate --help\n</code></pre></p> </li> <li> <p>[ ] IDE Integration (Optional)</p> </li> <li>Install VS Code extension: \"Portalis Translator\"</li> <li>Or PyCharm plugin: \"Portalis Integration\"</li> <li>Configure plugin with API key</li> <li>Test translation from IDE</li> </ul>"},{"location":"onboarding-checklist/#installation-verification","title":"Installation Verification","text":"<ul> <li> <p>[ ] System Requirements Check <pre><code># Check Python version\npython --version  # Should be 3.8+\n\n# Check available memory\nfree -h  # Recommended: 8GB+ RAM\n\n# Check disk space\ndf -h  # Need 10GB+ free\n\n# Check GPU (if available)\nnvidia-smi  # Optional but beneficial\n</code></pre></p> </li> <li> <p>[ ] Dependencies Verification <pre><code># Verify Rust toolchain (for local builds)\nrustc --version  # Should be 1.70+\ncargo --version\n\n# Verify WASM tools\nwasm-pack --version\n\n# Verify Docker (for containerized deployments)\ndocker --version\ndocker-compose --version\n</code></pre></p> </li> <li> <p>[ ] Network Configuration</p> </li> <li>Verify outbound HTTPS access (port 443)</li> <li>Whitelist API endpoint: api.portalis.ai</li> <li>Whitelist model serving: models.portalis.ai</li> <li>Configure proxy settings if needed</li> <li>Test API connectivity:     <pre><code>curl -H \"Authorization: Bearer &lt;api-key&gt;\" https://api.portalis.ai/v1/health\n</code></pre></li> </ul>"},{"location":"onboarding-checklist/#first-translation-walkthrough","title":"First Translation Walkthrough","text":"<ul> <li>[ ] Prepare Sample Code</li> <li>Select simple Python file (50-100 LOC)</li> <li>Ensure file has comprehensive tests</li> <li>Document expected behavior</li> <li> <p>Create backup of original file</p> </li> <li> <p>[ ] Execute Translation (CLI) <pre><code># Translate single file\nportalis translate input.py --output output.rs\n\n# Verify generated Rust code\ncat output.rs\n\n# Build Rust to WASM\nportalis build output.rs --target wasm32-wasi\n\n# Validate WASM output\nportalis validate output.wasm\n</code></pre></p> </li> <li> <p>[ ] Execute Translation (API) <pre><code>from portalis import PortalisClient\n\n# Initialize client\nclient = PortalisClient(api_key=\"&lt;your-key&gt;\")\n\n# Translate code\nresult = client.translate_file(\"input.py\")\n\n# Save output\nwith open(\"output.rs\", \"w\") as f:\n    f.write(result.rust_code)\n\n# Build to WASM\nwasm_result = client.build_wasm(result.rust_code)\n\n# Validate\nvalidation = client.validate_wasm(wasm_result.wasm_binary)\nprint(f\"Valid: {validation.is_valid}\")\n</code></pre></p> </li> <li> <p>[ ] Review Translation Quality</p> </li> <li>Compare input Python and output Rust</li> <li>Verify type mappings are correct</li> <li>Check API compatibility</li> <li>Review generated documentation</li> <li> <p>Note any issues or concerns</p> </li> <li> <p>[ ] Test Translated Code <pre><code># Run Rust tests\ncargo test --manifest-path output/Cargo.toml\n\n# Run WASM in Node.js\nnode test-wasm.js\n\n# Compare behavior with Python original\npython test_original.py\ndiff python_output.txt wasm_output.txt\n</code></pre></p> </li> <li> <p>[ ] Document Results</p> </li> <li>Translation success: Yes/No</li> <li>Build success: Yes/No</li> <li>Tests passing: X/Y</li> <li>Performance comparison: X ms (Python) vs Y ms (WASM)</li> <li>Issues encountered: [list]</li> <li>Questions raised: [list]</li> </ul>"},{"location":"onboarding-checklist/#week-1-assessment-tool-usage","title":"Week 1: Assessment Tool Usage","text":""},{"location":"onboarding-checklist/#feature-detection","title":"Feature Detection","text":"<ul> <li> <p>[ ] Run Feature Analyzer <pre><code># Analyze Python codebase\nportalis assess analyze --path /path/to/project\n\n# Review detected features\nportalis assess report --format json &gt; features.json\n\n# Check compatibility score\nportalis assess compatibility --threshold 0.8\n</code></pre></p> </li> <li> <p>[ ] Review Feature Report</p> </li> <li>Total Python features detected: ____</li> <li>Features fully supported: ____</li> <li>Features partially supported: ____</li> <li>Features not supported: ____</li> <li> <p>Compatibility score: ____%</p> </li> <li> <p>[ ] Identify Gaps</p> </li> <li>List unsupported features: [____]</li> <li>Assess impact on translation: High/Medium/Low</li> <li>Plan workarounds or alternatives</li> <li>Submit feature requests if needed</li> </ul>"},{"location":"onboarding-checklist/#complexity-assessment","title":"Complexity Assessment","text":"<ul> <li> <p>[ ] Run Complexity Analysis <pre><code># Analyze code complexity\nportalis assess complexity --path /path/to/project\n\n# Get detailed metrics\nportalis assess metrics --include-all\n</code></pre></p> </li> <li> <p>[ ] Review Complexity Metrics</p> </li> <li>Cyclomatic complexity: ____</li> <li>Lines of code: ____</li> <li>Number of functions/classes: ____</li> <li>Dependency count: ____</li> <li> <p>Estimated translation time: ____</p> </li> <li> <p>[ ] Risk Assessment</p> </li> <li>Translation risk level: Low/Medium/High</li> <li>Identify high-risk modules</li> <li>Plan phased translation approach</li> <li>Define success criteria</li> </ul>"},{"location":"onboarding-checklist/#performance-estimation","title":"Performance Estimation","text":"<ul> <li> <p>[ ] Run Performance Predictor <pre><code># Estimate performance gains\nportalis assess performance --path /path/to/project\n\n# Compare CPU vs GPU acceleration\nportalis assess performance --mode comparison\n</code></pre></p> </li> <li> <p>[ ] Review Estimates</p> </li> <li>Estimated speedup (CPU): ____x</li> <li>Estimated speedup (GPU): ____x</li> <li>Memory reduction: ____%</li> <li>Cost per translation: $____</li> <li>Total translation time: ____ minutes</li> </ul>"},{"location":"onboarding-checklist/#week-2-migration-planning","title":"Week 2: Migration Planning","text":""},{"location":"onboarding-checklist/#migration-strategy","title":"Migration Strategy","text":"<ul> <li>[ ] Define Translation Phases</li> <li>Phase 1: Pilot modules (1-2 weeks)<ul> <li>Modules: [list]</li> <li>Success criteria: [define]</li> </ul> </li> <li>Phase 2: Core functionality (3-4 weeks)<ul> <li>Modules: [list]</li> <li>Success criteria: [define]</li> </ul> </li> <li> <p>Phase 3: Full migration (timeline: ____)</p> <ul> <li>Modules: [list]</li> <li>Success criteria: [define]</li> </ul> </li> <li> <p>[ ] Risk Mitigation Plan</p> </li> <li>Identify critical dependencies</li> <li>Plan for unsupported features</li> <li>Define rollback procedures</li> <li>Set up parallel testing environment</li> <li> <p>Document fallback strategies</p> </li> <li> <p>[ ] Resource Planning</p> </li> <li>Engineering time allocated: ____ hours</li> <li>QA time allocated: ____ hours</li> <li>Infrastructure costs: $____/month</li> <li>Timeline: ____ weeks</li> <li>Key milestones: [list]</li> </ul>"},{"location":"onboarding-checklist/#integration-planning","title":"Integration Planning","text":"<ul> <li>[ ] CI/CD Integration</li> <li>Identify CI/CD platform (Jenkins, GitHub Actions, GitLab CI)</li> <li>Plan Portalis integration points</li> <li>Define automated testing strategy</li> <li>Set up deployment pipeline</li> <li> <p>Configure rollback mechanisms</p> </li> <li> <p>[ ] Testing Strategy</p> </li> <li>Unit tests: Translate and adapt</li> <li>Integration tests: Define WASM test harness</li> <li>Performance tests: Benchmark suite</li> <li>Regression tests: Automated comparison</li> <li> <p>Acceptance tests: Production validation</p> </li> <li> <p>[ ] Deployment Strategy</p> </li> <li>Deployment target: Kubernetes/Docker/Serverless</li> <li>Scaling strategy: Auto-scaling policies</li> <li>Monitoring: Metrics and alerting</li> <li>Logging: Centralized log aggregation</li> <li>Backup &amp; recovery: DR plan</li> </ul>"},{"location":"onboarding-checklist/#success-metrics-definition","title":"Success Metrics Definition","text":"<ul> <li>[ ] Technical Metrics</li> <li>Translation success rate target: ____%</li> <li>Build success rate target: ____%</li> <li>Test pass rate target: ____%</li> <li>Performance improvement target: ____x</li> <li> <p>Code coverage target: ____%</p> </li> <li> <p>[ ] Business Metrics</p> </li> <li>Cost reduction target: ____%</li> <li>Time to market improvement: ____%</li> <li>Developer productivity gain: ____%</li> <li>Operational cost savings: $____/month</li> <li> <p>ROI timeline: ____ months</p> </li> <li> <p>[ ] Quality Metrics</p> </li> <li>Bug density target: &lt; ____ bugs/1K LOC</li> <li>Critical bug tolerance: 0</li> <li>Security vulnerability target: 0</li> <li>Performance regression tolerance: &lt; ____%</li> <li>Uptime target: ____%</li> </ul>"},{"location":"onboarding-checklist/#week-2-support-contact-information","title":"Week 2: Support Contact Information","text":""},{"location":"onboarding-checklist/#your-customer-success-team","title":"Your Customer Success Team","text":"<ul> <li>[ ] Primary Contacts Documented</li> <li> <p>Customer Success Engineer: ______</p> <ul> <li>Email: ______</li> <li>Slack: @______</li> <li>Phone: ______</li> </ul> </li> <li> <p>Technical Account Manager: ______</p> <ul> <li>Email: ______</li> <li>Slack: @______</li> <li>Phone: ______</li> </ul> </li> <li> <p>Product Manager: ______</p> <ul> <li>Email: ______</li> <li>Slack: @______</li> </ul> </li> <li> <p>[ ] Escalation Path Confirmed</p> </li> <li>Level 1: Community support (Slack, &lt;4 hours)</li> <li>Level 2: Engineering support (Ticket, &lt;24 hours)</li> <li>Level 3: Critical escalation (Phone, &lt;2 hours)</li> <li> <p>Emergency: Hotline +1 (555) 123-BETA (24/7)</p> </li> <li> <p>[ ] Communication Preferences Set</p> </li> <li>Preferred contact method: ______</li> <li>Notification preferences: ______</li> <li>Meeting schedule confirmed: ______</li> <li>Time zone: ______</li> </ul>"},{"location":"onboarding-checklist/#support-resources","title":"Support Resources","text":"<ul> <li>[ ] Documentation Bookmarked</li> <li>[ ] Getting Started Guide: docs.portalis.ai/getting-started</li> <li>[ ] API Reference: api.portalis.ai/docs</li> <li>[ ] CLI Documentation: docs.portalis.ai/cli</li> <li>[ ] Best Practices: docs.portalis.ai/best-practices</li> <li>[ ] Troubleshooting Guide: docs.portalis.ai/troubleshooting</li> <li> <p>[ ] FAQ: docs.portalis.ai/faq</p> </li> <li> <p>[ ] Tools &amp; Utilities</p> </li> <li>[ ] Beta Dashboard: app.portalis.ai/beta</li> <li>[ ] Metrics Dashboard: metrics.portalis.ai</li> <li>[ ] Status Page: status.portalis.ai</li> <li>[ ] Feedback Portal: feedback.portalis.ai</li> <li> <p>[ ] Community Forum: community.portalis.ai</p> </li> <li> <p>[ ] Training Resources</p> </li> <li>[ ] Video tutorials viewed: ____/10</li> <li>[ ] Sample projects cloned: ____/3</li> <li>[ ] Documentation review: ____%</li> <li>[ ] Best practices guide read: Yes/No</li> </ul>"},{"location":"onboarding-checklist/#ongoing-activities-weekly","title":"Ongoing Activities (Weekly)","text":""},{"location":"onboarding-checklist/#week-3-checklist","title":"Week 3+ Checklist","text":"<ul> <li>[ ] Weekly Check-in Preparation</li> <li>Document previous week's progress</li> <li>List current blockers and issues</li> <li>Prepare questions for engineering team</li> <li>Review metrics and KPIs</li> <li> <p>Update project status</p> </li> <li> <p>[ ] Continuous Integration</p> </li> <li>Run daily translations (if applicable)</li> <li>Monitor build success rates</li> <li>Track performance metrics</li> <li>Review error logs</li> <li> <p>Update documentation</p> </li> <li> <p>[ ] Feedback Submission</p> </li> <li>Submit bug reports as discovered</li> <li>Provide feature requests with context</li> <li>Complete weekly satisfaction survey</li> <li>Participate in monthly retrospectives</li> <li> <p>Share success stories</p> </li> <li> <p>[ ] Knowledge Building</p> </li> <li>Review new documentation releases</li> <li>Attend office hours (Fridays 2-3 PM PT)</li> <li>Participate in beta community discussions</li> <li>Share learnings with internal team</li> <li>Document internal best practices</li> </ul>"},{"location":"onboarding-checklist/#milestone-checklist","title":"Milestone Checklist","text":""},{"location":"onboarding-checklist/#end-of-week-2-milestone","title":"End of Week 2 Milestone","text":"<ul> <li>[ ] Onboarding Complete</li> <li>All accounts and access configured</li> <li>First successful translation completed</li> <li>Assessment tools used and understood</li> <li>Migration plan documented</li> <li>Support contacts established</li> <li> <p>Team trained on basic usage</p> </li> <li> <p>[ ] Readiness Validation</p> </li> <li>Technical environment validated</li> <li>Integration points identified</li> <li>Success metrics defined</li> <li>Risks documented and mitigated</li> <li>Timeline established</li> <li>Stakeholder alignment confirmed</li> </ul>"},{"location":"onboarding-checklist/#end-of-week-4-milestone","title":"End of Week 4 Milestone","text":"<ul> <li>[ ] Pilot Complete</li> <li>First module successfully translated</li> <li>Tests passing for translated code</li> <li>Performance benchmarks completed</li> <li>Issues documented and resolved</li> <li>Lessons learned captured</li> <li>Plan adjusted based on findings</li> </ul>"},{"location":"onboarding-checklist/#end-of-week-8-milestone","title":"End of Week 8 Milestone","text":"<ul> <li>[ ] Production Integration</li> <li>Core modules translated</li> <li>CI/CD pipeline operational</li> <li>Monitoring and alerting configured</li> <li>Performance targets met</li> <li>Quality metrics achieved</li> <li>Team fully proficient</li> </ul>"},{"location":"onboarding-checklist/#end-of-week-12-milestone","title":"End of Week 12 Milestone","text":"<ul> <li>[ ] Beta Graduation</li> <li>All planned modules translated</li> <li>Production deployment successful</li> <li>Success metrics exceeded</li> <li>Case study completed</li> <li>Feedback provided</li> <li>Ready for GA transition</li> </ul>"},{"location":"onboarding-checklist/#emergency-procedures","title":"Emergency Procedures","text":""},{"location":"onboarding-checklist/#critical-issue-response","title":"Critical Issue Response","text":"<p>If you encounter a production-blocking issue:</p> <ol> <li>Immediate Actions:</li> <li>[ ] Call emergency hotline: +1 (555) 123-BETA</li> <li>[ ] Post in #beta-technical with @here mention</li> <li>[ ] Email: beta-support@portalis.ai with [CRITICAL] tag</li> <li> <p>[ ] Document issue details: symptoms, impact, timeline</p> </li> <li> <p>Information to Provide:</p> </li> <li>[ ] Description of the issue</li> <li>[ ] Impact on your operations</li> <li>[ ] Steps to reproduce</li> <li>[ ] Error messages and logs</li> <li>[ ] Environment details</li> <li> <p>[ ] Temporary workarounds attempted</p> </li> <li> <p>Escalation Timeline:</p> </li> <li>[ ] 0-30 min: Initial response from on-call engineer</li> <li>[ ] 30-60 min: Senior engineer assigned</li> <li>[ ] 60-120 min: Root cause analysis begins</li> <li>[ ] 2-4 hours: Temporary mitigation provided</li> <li>[ ] 4-24 hours: Permanent fix deployed</li> </ol>"},{"location":"onboarding-checklist/#rollback-procedures","title":"Rollback Procedures","text":"<p>If you need to rollback a translation:</p> <ol> <li> <p>Immediate Rollback:    <pre><code># Revert to Python version\nportalis rollback --deployment &lt;deployment-id&gt;\n\n# Or manual rollback\nkubectl rollout undo deployment/your-service\ndocker-compose down &amp;&amp; docker-compose -f docker-compose.old.yml up\n</code></pre></p> </li> <li> <p>Document Rollback:</p> </li> <li>[ ] Reason for rollback</li> <li>[ ] Issue encountered</li> <li>[ ] Impact assessment</li> <li>[ ] Notify support team</li> <li>[ ] Plan remediation</li> </ol>"},{"location":"onboarding-checklist/#completion-sign-off","title":"Completion Sign-off","text":""},{"location":"onboarding-checklist/#onboarding-certification","title":"Onboarding Certification","text":"<p>Beta Customer: _______ (Company)</p> <p>Technical Lead: _______ (Name)</p> <p>Date Completed: _______</p> <p>Portalis Customer Success Engineer: _______</p> <p>Signature: ____ Date: ____</p>"},{"location":"onboarding-checklist/#onboarding-status","title":"Onboarding Status","text":"<ul> <li>[ ] Week 1 Complete: Account setup, first translation successful</li> <li>[ ] Week 2 Complete: Assessment done, migration plan created</li> <li>[ ] Ready for Production Testing: All prerequisites met</li> </ul> <p>Next Steps: 1. Begin pilot module translation (Week 3) 2. Schedule first retrospective (Week 4) 3. Plan production integration (Weeks 5-8)</p>"},{"location":"onboarding-checklist/#appendix-quick-reference","title":"Appendix: Quick Reference","text":""},{"location":"onboarding-checklist/#essential-commands","title":"Essential Commands","text":"<pre><code># Authentication\nportalis auth login\nportalis auth test\n\n# Translation\nportalis translate &lt;file.py&gt; --output &lt;file.rs&gt;\nportalis build &lt;file.rs&gt; --target wasm32-wasi\nportalis validate &lt;file.wasm&gt;\n\n# Assessment\nportalis assess analyze --path &lt;project&gt;\nportalis assess compatibility --threshold 0.8\nportalis assess performance --mode gpu\n\n# Deployment\nportalis deploy --target kubernetes\nportalis deploy --target docker\nportalis status\n\n# Monitoring\nportalis metrics --live\nportalis logs --follow\nportalis health\n</code></pre>"},{"location":"onboarding-checklist/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"<p>Issue: API authentication fails Solution: Regenerate API key in dashboard, update configuration</p> <p>Issue: Translation fails with type errors Solution: Run <code>portalis assess analyze</code> to check compatibility</p> <p>Issue: WASM validation fails Solution: Ensure Rust toolchain is up to date, check build logs</p> <p>Issue: Performance below expectations Solution: Enable GPU acceleration, adjust batch size, contact support</p>"},{"location":"onboarding-checklist/#support-contacts","title":"Support Contacts","text":"<p>Beta Support Email: beta-support@portalis.ai Emergency Hotline: +1 (555) 123-BETA Slack: portalis-beta.slack.com Documentation: docs.portalis.ai Status: status.portalis.ai</p> <p>Welcome to Portalis Beta! \ud83d\ude80</p> <p>We're excited to have you on board. If you have any questions or need assistance at any point, don't hesitate to reach out. Our team is here to ensure your success!</p> <p>Version: 1.0 Last Updated: October 2025 Next Review: Monthly</p>"},{"location":"performance/","title":"Performance Tuning Guide","text":"<p>Optimize Portalis for maximum performance.</p>"},{"location":"performance/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"performance/#baseline-performance","title":"Baseline Performance","text":"Mode Throughput Latency (P95) GPU Required Pattern (CPU) 366,000 trans/sec 50ms No NeMo (GPU) 325 req/sec 315ms Yes CUDA Parsing (GPU) 37x speedup - Yes"},{"location":"performance/#end-to-end-performance","title":"End-to-End Performance","text":"<p>100 LOC Python file: - Pattern mode: ~50ms - NeMo mode: ~315ms (but higher quality) - 2-3x overall speedup with GPU</p>"},{"location":"performance/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"performance/#1-choose-the-right-mode","title":"1. Choose the Right Mode","text":"<p>Development: Use pattern mode <pre><code>portalis translate --input dev.py --mode pattern\n</code></pre></p> <p>Production: Use NeMo mode <pre><code>portalis translate --input prod.py --mode nemo\n</code></pre></p>"},{"location":"performance/#2-batch-processing","title":"2. Batch Processing","text":"<p>Process multiple files in parallel: <pre><code>portalis batch --input-dir ./src --parallel 8 --mode nemo\n</code></pre></p>"},{"location":"performance/#3-gpu-configuration","title":"3. GPU Configuration","text":"<p>Batch size (NeMo): <pre><code>[gpu]\nbatch_size = 32  # Optimal for most GPUs\n</code></pre></p> <p>Multiple GPUs: <pre><code>export CUDA_VISIBLE_DEVICES=0,1,2,3\n</code></pre></p>"},{"location":"performance/#4-caching","title":"4. Caching","text":"<p>Enable response caching: <pre><code>[cache]\nenabled = true\nttl_seconds = 86400  # 24 hours\nmax_size_mb = 1024\n</code></pre></p>"},{"location":"performance/#5-resource-limits","title":"5. Resource Limits","text":"<p>CPU allocation: <pre><code>resources:\n  requests:\n    cpu: \"2\"\n    memory: \"4Gi\"\n  limits:\n    cpu: \"4\"\n    memory: \"8Gi\"\n</code></pre></p>"},{"location":"performance/#benchmarking","title":"Benchmarking","text":""},{"location":"performance/#run-benchmarks","title":"Run Benchmarks","text":"<pre><code># Built-in benchmarks\ncargo bench\n\n# Translation benchmark\nportalis bench --input examples/ --iterations 100\n\n# GPU benchmark\nportalis bench --input large-file.py --mode nemo --gpu\n</code></pre>"},{"location":"performance/#expected-results","title":"Expected Results","text":"<p>CPU Mode: - Simple function: &lt;1ms - 100 LOC file: ~50ms - 1000 LOC file: ~500ms</p> <p>GPU Mode: - Simple function: ~150ms (including network overhead) - 100 LOC file: ~315ms - 1000 LOC file: ~800ms</p> <p>GPU Parsing: - 100 LOC: 10x speedup - 1K LOC: 20x speedup - 10K LOC: 37x speedup</p>"},{"location":"performance/#cost-optimization","title":"Cost Optimization","text":""},{"location":"performance/#dgx-cloud","title":"DGX Cloud","text":"<p>Spot instances: 70% spot, 30% on-demand - 30% cost reduction - Automatic fallback on interruption</p> <p>Auto-scaling: <pre><code>autoscaling:\n  minReplicas: 2\n  maxReplicas: 10\n  targetGPUUtilization: 75%\n</code></pre></p>"},{"location":"performance/#pricing","title":"Pricing","text":"<p>Per translation cost: $0.008 (92% below $0.10 target)</p> <p>Optimization tips: 1. Use pattern mode for simple code 2. Batch requests for better GPU utilization 3. Enable caching for repeated requests 4. Use spot instances for non-critical workloads</p>"},{"location":"performance/#monitoring-performance","title":"Monitoring Performance","text":""},{"location":"performance/#metrics-to-track","title":"Metrics to Track","text":"<ul> <li>Throughput: Requests per second</li> <li>Latency: P50, P95, P99</li> <li>GPU Utilization: Target 70%+</li> <li>Cache Hit Rate: Target 30%+</li> <li>Error Rate: Target &lt;2%</li> </ul>"},{"location":"performance/#grafana-dashboards","title":"Grafana Dashboards","text":"<p>Import dashboard ID: 12345</p> <p>Key panels: - Translation latency histogram - GPU utilization over time - Cache hit rate - Error rate by type</p>"},{"location":"performance/#troubleshooting-performance","title":"Troubleshooting Performance","text":""},{"location":"performance/#low-gpu-utilization","title":"Low GPU Utilization","text":"<p>Increase batch size: <pre><code>[gpu]\nbatch_size = 64\n</code></pre></p> <p>Enable request batching: <pre><code>[services.nemo]\nbatch_timeout_ms = 100\n</code></pre></p>"},{"location":"performance/#high-latency","title":"High Latency","text":"<p>Check network latency: <pre><code># Ping NeMo service\ncurl -w \"@curl-format.txt\" http://nemo-service:8000/health\n</code></pre></p> <p>Optimize WASM compilation: <pre><code>[optimization]\nopt_level = \"z\"  # Optimize for size\nlto = true\n</code></pre></p>"},{"location":"performance/#memory-issues","title":"Memory Issues","text":"<p>Reduce batch size: <pre><code>[gpu]\nmemory_limit_mb = 6144\nbatch_size = 16\n</code></pre></p> <p>Enable streaming: <pre><code>[translation]\nstreaming = true\n</code></pre></p>"},{"location":"performance/#see-also","title":"See Also","text":"<ul> <li>Architecture Overview</li> <li>Kubernetes Deployment</li> <li>Benchmarking Guide</li> </ul>"},{"location":"python-compatibility/","title":"Python Compatibility Matrix","text":"<p>This document details the Python language features supported by Portalis and their translation quality levels.</p>"},{"location":"python-compatibility/#translation-quality-levels","title":"Translation Quality Levels","text":"Level Description Characteristics Full Complete translation with high fidelity 95%+ correctness, production-ready Partial Functional translation with limitations 80-95% correctness, may need manual review Unsupported Not yet implemented Workarounds available or future roadmap"},{"location":"python-compatibility/#version-support","title":"Version Support","text":"Python Version Support Level Notes 3.11 Full Recommended, fully tested 3.10 Full All features supported 3.9 Partial Most features, some stdlib limitations 3.8 Partial Core features only &lt;3.8 Unsupported Use Python 3.9+"},{"location":"python-compatibility/#core-language-features","title":"Core Language Features","text":""},{"location":"python-compatibility/#data-types","title":"Data Types","text":"Feature Quality Rust Equivalent Notes <code>int</code> Full <code>i64</code> Arbitrary precision not supported <code>float</code> Full <code>f64</code> IEEE 754 double precision <code>str</code> Full <code>String</code> UTF-8 encoding <code>bool</code> Full <code>bool</code> Direct mapping <code>bytes</code> Full <code>Vec&lt;u8&gt;</code> Byte arrays <code>list</code> Full <code>Vec&lt;T&gt;</code> Homogeneous types only <code>tuple</code> Full <code>(T1, T2, ...)</code> Fixed-size tuples <code>dict</code> Partial <code>HashMap&lt;K, V&gt;</code> Requires hashable keys <code>set</code> Partial <code>HashSet&lt;T&gt;</code> Requires hashable values <code>None</code> Full <code>Option::None</code> Optional types"},{"location":"python-compatibility/#control-flow","title":"Control Flow","text":"Feature Quality Notes <code>if/elif/else</code> Full Direct translation <code>for</code> loop Full Iterator-based <code>while</code> loop Full Direct translation <code>break</code> Full Supported <code>continue</code> Full Supported <code>match</code> (3.10+) Partial Simple patterns only <code>pass</code> Full Empty block <code>return</code> Full Early returns supported"},{"location":"python-compatibility/#functions","title":"Functions","text":"Feature Quality Notes Function definitions Full <code>def func():</code> \u2192 <code>pub fn func()</code> Type hints Full Strongly encouraged Default arguments Full Compile-time defaults Keyword arguments Partial Requires named parameters <code>*args</code> Partial Translated to <code>Vec&lt;T&gt;</code> <code>**kwargs</code> Unsupported Use structs instead Lambda functions Partial Simple lambdas only Closures Partial Limited capture support Decorators Partial Common decorators only Async functions Partial Tokio runtime required"},{"location":"python-compatibility/#classes-and-oop","title":"Classes and OOP","text":"Feature Quality Rust Equivalent Notes Class definition Full <code>struct</code> + <code>impl</code> Direct translation <code>__init__</code> Full Associated function Constructor Instance methods Full <code>&amp;self</code> methods Class methods Full <code>Self</code> parameter <code>@classmethod</code> Static methods Full Associated functions <code>@staticmethod</code> Properties Partial Getter/setter methods <code>@property</code> Inheritance Partial Trait-based Single inheritance Multiple inheritance Unsupported Use composition <code>super()</code> Partial Explicit parent calls Magic methods Partial See table below"},{"location":"python-compatibility/#magic-methods","title":"Magic Methods","text":"Python Rust Quality Notes <code>__str__</code> <code>Display</code> trait Full String representation <code>__repr__</code> <code>Debug</code> trait Full Debug representation <code>__eq__</code> <code>PartialEq</code> trait Full Equality <code>__lt__</code>, <code>__gt__</code> <code>PartialOrd</code> trait Full Comparison <code>__add__</code>, <code>__sub__</code> Operator traits Full Arithmetic <code>__len__</code> Method Full Length/size <code>__getitem__</code> Index trait Partial Array access <code>__iter__</code> <code>Iterator</code> trait Partial Iteration <code>__call__</code> <code>Fn</code> trait Unsupported Use methods"},{"location":"python-compatibility/#type-annotations","title":"Type Annotations","text":""},{"location":"python-compatibility/#built-in-types","title":"Built-in Types","text":"Python Type Rust Type Quality Notes <code>int</code> <code>i64</code> Full Default integer <code>float</code> <code>f64</code> Full Default float <code>str</code> <code>String</code> Full UTF-8 strings <code>bool</code> <code>bool</code> Full Boolean <code>None</code> <code>Option::None</code> Full Null value <code>Any</code> Generic <code>T</code> Partial Type erasure limitations"},{"location":"python-compatibility/#generic-types","title":"Generic Types","text":"Python Type Rust Type Quality Notes <code>List[T]</code> <code>Vec&lt;T&gt;</code> Full Homogeneous lists <code>Tuple[T1, T2]</code> <code>(T1, T2)</code> Full Fixed-size tuples <code>Dict[K, V]</code> <code>HashMap&lt;K, V&gt;</code> Full Hash-based maps <code>Set[T]</code> <code>HashSet&lt;T&gt;</code> Full Hash-based sets <code>Optional[T]</code> <code>Option&lt;T&gt;</code> Full Nullable types <code>Union[T1, T2]</code> <code>enum</code> Partial Tagged unions <code>Callable[[Args], Ret]</code> <code>Fn(Args) -&gt; Ret</code> Partial Function types"},{"location":"python-compatibility/#typing-module","title":"Typing Module","text":"Python Rust Equivalent Quality Notes <code>List</code> <code>Vec</code> Full <code>Dict</code> <code>HashMap</code> Full <code>Set</code> <code>HashSet</code> Full <code>Optional</code> <code>Option</code> Full <code>Union</code> <code>enum</code> Partial <code>Literal</code> <code>const</code> Partial Compile-time values <code>TypeVar</code> Generic <code>&lt;T&gt;</code> Partial Generic type parameters <code>Protocol</code> Trait Partial Structural typing <code>NewType</code> Type alias Full"},{"location":"python-compatibility/#standard-library","title":"Standard Library","text":""},{"location":"python-compatibility/#commonly-supported-modules","title":"Commonly Supported Modules","text":"Module Quality Rust Equivalent Notes <code>math</code> Full <code>std::f64</code> Math functions <code>random</code> Full <code>rand</code> crate Random numbers <code>datetime</code> Partial <code>chrono</code> crate Date/time handling <code>json</code> Full <code>serde_json</code> JSON serialization <code>re</code> Partial <code>regex</code> crate Regular expressions <code>os.path</code> Partial <code>std::path</code> Path manipulation <code>collections</code> Full <code>std::collections</code> Data structures"},{"location":"python-compatibility/#limited-support","title":"Limited Support","text":"Module Quality Workaround Notes <code>sys</code> Partial Platform-specific System info limited <code>io</code> Partial <code>std::io</code> File I/O supported <code>threading</code> Unsupported Use Tokio async No GIL in Rust <code>multiprocessing</code> Unsupported Use async/await Process-based concurrency <code>ctypes</code> Unsupported FFI directly Use Rust FFI <code>pickle</code> Unsupported Use <code>serde</code> Serialization"},{"location":"python-compatibility/#unsupported-modules","title":"Unsupported Modules","text":"<p>These modules cannot be directly translated:</p> <ul> <li><code>tkinter</code> - GUI framework (use web UI)</li> <li><code>asyncio</code> - Python-specific (use Tokio)</li> <li><code>importlib</code> - Dynamic imports unsupported</li> <li><code>inspect</code> - Reflection limited in Rust</li> <li><code>gc</code> - Rust has different memory model</li> </ul>"},{"location":"python-compatibility/#operators","title":"Operators","text":""},{"location":"python-compatibility/#arithmetic-operators","title":"Arithmetic Operators","text":"Operator Quality Notes <code>+</code> Full Addition <code>-</code> Full Subtraction <code>*</code> Full Multiplication <code>/</code> Full Float division <code>//</code> Full Integer division <code>%</code> Full Modulo <code>**</code> Full Power (via <code>powi</code>/<code>powf</code>)"},{"location":"python-compatibility/#comparison-operators","title":"Comparison Operators","text":"Operator Quality Notes <code>==</code> Full Equality <code>!=</code> Full Inequality <code>&lt;</code>, <code>&gt;</code> Full Less/greater than <code>&lt;=</code>, <code>&gt;=</code> Full Less/greater or equal <code>is</code> Partial Pointer equality <code>is not</code> Partial Pointer inequality <code>in</code> Partial Collection membership"},{"location":"python-compatibility/#logical-operators","title":"Logical Operators","text":"Operator Quality Notes <code>and</code> Full Logical AND <code>or</code> Full Logical OR <code>not</code> Full Logical NOT"},{"location":"python-compatibility/#bitwise-operators","title":"Bitwise Operators","text":"Operator Quality Notes <code>&amp;</code> Full Bitwise AND <code>|</code> Full Bitwise OR <code>^</code> Full Bitwise XOR <code>~</code> Full Bitwise NOT <code>&lt;&lt;</code> Full Left shift <code>&gt;&gt;</code> Full Right shift"},{"location":"python-compatibility/#comprehensions","title":"Comprehensions","text":"Feature Quality Rust Equivalent Notes List comprehension Full <code>iter().map().collect()</code> <code>[x for x in items]</code> Dict comprehension Partial <code>iter().collect()</code> Simple cases only Set comprehension Partial <code>iter().collect()</code> Simple cases only Generator expression Partial <code>Iterator</code> Lazy evaluation <p>Example: <pre><code># Python\nsquares = [x**2 for x in range(10) if x % 2 == 0]\n\n# Translated Rust\nlet squares: Vec&lt;i64&gt; = (0..10)\n    .filter(|x| x % 2 == 0)\n    .map(|x| x.pow(2))\n    .collect();\n</code></pre></p>"},{"location":"python-compatibility/#exception-handling","title":"Exception Handling","text":"Feature Quality Rust Equivalent Notes <code>try/except</code> Partial <code>Result&lt;T, E&gt;</code> Error handling <code>finally</code> Partial Drop trait Cleanup <code>raise</code> Partial <code>Err(...)</code> Error propagation Custom exceptions Partial Custom error types Exception hierarchy Unsupported Flat error types <p>Example: <pre><code># Python\ntry:\n    result = risky_operation()\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n    result = None\n\n# Translated Rust\nlet result = match risky_operation() {\n    Ok(val) =&gt; Some(val),\n    Err(e) =&gt; {\n        println!(\"Error: {}\", e);\n        None\n    }\n};\n</code></pre></p>"},{"location":"python-compatibility/#asyncawait","title":"Async/Await","text":"Feature Quality Rust Equivalent Notes <code>async def</code> Partial <code>async fn</code> Tokio runtime <code>await</code> Partial <code>.await</code> Async operations <code>asyncio.gather</code> Partial <code>tokio::join!</code> Parallel execution <code>asyncio.create_task</code> Partial <code>tokio::spawn</code> Task spawning"},{"location":"python-compatibility/#known-limitations","title":"Known Limitations","text":""},{"location":"python-compatibility/#1-dynamic-typing","title":"1. Dynamic Typing","text":"<p>Issue: Python's dynamic nature doesn't map directly to Rust.</p> <p>Workaround: Use comprehensive type hints. <pre><code># Good - translates well\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\n# Poor - translation may fail\ndef add(a, b):\n    return a + b\n</code></pre></p>"},{"location":"python-compatibility/#2-duck-typing","title":"2. Duck Typing","text":"<p>Issue: Structural typing is limited.</p> <p>Workaround: Use explicit traits/protocols.</p>"},{"location":"python-compatibility/#3-monkey-patching","title":"3. Monkey Patching","text":"<p>Issue: Runtime modification unsupported.</p> <p>Workaround: Refactor to use composition.</p>"},{"location":"python-compatibility/#4-eval-and-exec","title":"4. <code>eval()</code> and <code>exec()</code>","text":"<p>Issue: Dynamic code execution impossible.</p> <p>Workaround: Redesign using static approaches.</p>"},{"location":"python-compatibility/#5-multiple-inheritance","title":"5. Multiple Inheritance","text":"<p>Issue: Rust supports single inheritance via traits.</p> <p>Workaround: Use trait composition.</p>"},{"location":"python-compatibility/#6-global-interpreter-lock-gil","title":"6. Global Interpreter Lock (GIL)","text":"<p>Issue: GIL semantics don't exist in Rust.</p> <p>Benefit: True parallelism with threads!</p>"},{"location":"python-compatibility/#workarounds-for-unsupported-features","title":"Workarounds for Unsupported Features","text":""},{"location":"python-compatibility/#keyword-arguments-kwargs","title":"Keyword Arguments (<code>**kwargs</code>)","text":"<pre><code># Python - unsupported\ndef configure(**kwargs):\n    pass\n\n# Workaround - use struct\nfrom dataclasses import dataclass\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n    port: int = 8080\n\ndef configure(config: Config):\n    pass\n</code></pre>"},{"location":"python-compatibility/#dynamic-attributes","title":"Dynamic Attributes","text":"<pre><code># Python - unsupported\nobj.new_attr = \"value\"\n\n# Workaround - use HashMap\nfrom typing import Dict, Any\n\nclass DynamicObject:\n    def __init__(self):\n        self.attrs: Dict[str, Any] = {}\n\n    def set_attr(self, key: str, value: Any):\n        self.attrs[key] = value\n</code></pre>"},{"location":"python-compatibility/#metaclasses","title":"Metaclasses","text":"<pre><code># Python - unsupported\nclass Meta(type):\n    pass\n\n# Workaround - use procedural macros in Rust\n# Or refactor to avoid metaclasses\n</code></pre>"},{"location":"python-compatibility/#future-roadmap","title":"Future Roadmap","text":"<p>Features planned for future releases:</p>"},{"location":"python-compatibility/#short-term-3-6-months","title":"Short Term (3-6 months)","text":"<ul> <li>[ ] Full <code>async/await</code> support</li> <li>[ ] Generator functions</li> <li>[ ] Context managers (<code>with</code> statement)</li> <li>[ ] More magic methods</li> <li>[ ] Enhanced type inference</li> </ul>"},{"location":"python-compatibility/#medium-term-6-12-months","title":"Medium Term (6-12 months)","text":"<ul> <li>[ ] <code>dataclasses</code> full support</li> <li>[ ] <code>pathlib</code> integration</li> <li>[ ] More stdlib modules</li> <li>[ ] Protocol/structural typing</li> <li>[ ] Advanced comprehensions</li> </ul>"},{"location":"python-compatibility/#long-term-12-months","title":"Long Term (12+ months)","text":"<ul> <li>[ ] Partial <code>**kwargs</code> support</li> <li>[ ] Limited reflection</li> <li>[ ] Dynamic typing fallback</li> <li>[ ] CPython extension interop</li> <li>[ ] NumPy array translation</li> </ul>"},{"location":"python-compatibility/#testing-compatibility","title":"Testing Compatibility","text":"<p>Use our compatibility checker:</p> <pre><code>portalis check-compat --input myfile.py\n\n# Output:\n# \u2705 45 features fully supported\n# \u26a0\ufe0f  3 features partially supported\n# \u274c 2 features unsupported\n#\n# Partial support:\n#   - Line 23: Dict comprehension (simple patterns only)\n#   - Line 45: Property decorator (basic support)\n#   - Line 67: Multiple inheritance (use traits)\n#\n# Unsupported:\n#   - Line 89: **kwargs (use struct)\n#   - Line 102: eval() (refactor to static)\n#\n# Recommendation: 93% compatible - ready for translation\n</code></pre>"},{"location":"python-compatibility/#best-practices","title":"Best Practices","text":""},{"location":"python-compatibility/#1-use-type-hints-everywhere","title":"1. Use Type Hints Everywhere","text":"<pre><code># Good\ndef calculate(x: float, y: float) -&gt; float:\n    return x + y\n\n# Avoid\ndef calculate(x, y):\n    return x + y\n</code></pre>"},{"location":"python-compatibility/#2-prefer-composition-over-inheritance","title":"2. Prefer Composition Over Inheritance","text":"<pre><code># Good\nclass Logger:\n    pass\n\nclass Service:\n    def __init__(self, logger: Logger):\n        self.logger = logger\n\n# Avoid deep inheritance hierarchies\n</code></pre>"},{"location":"python-compatibility/#3-use-standard-library","title":"3. Use Standard Library","text":"<pre><code># Good - translates to Rust easily\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n</code></pre>"},{"location":"python-compatibility/#4-avoid-dynamic-features","title":"4. Avoid Dynamic Features","text":"<pre><code># Avoid\nexec(\"x = 5\")\ngetattr(obj, \"dynamic_attr\")\nsetattr(obj, \"dynamic_attr\", value)\n\n# Prefer static access\nx = 5\nobj.static_attr\nobj.static_attr = value\n</code></pre>"},{"location":"python-compatibility/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>CLI Reference</li> <li>Troubleshooting Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"security/","title":"Security Guide","text":"<p>Comprehensive security documentation for deploying and operating Portalis in enterprise environments.</p>"},{"location":"security/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Threat Modeling</li> <li>WASM Sandboxing</li> <li>Container Security</li> <li>Network Security</li> <li>Authentication &amp; Authorization</li> <li>Secret Management</li> <li>Security Testing</li> <li>Vulnerability Management</li> <li>Incident Response</li> <li>Compliance &amp; Auditing</li> <li>Security Best Practices</li> <li>Reporting Security Issues</li> </ul>"},{"location":"security/#threat-modeling","title":"Threat Modeling","text":""},{"location":"security/#attack-surface-analysis","title":"Attack Surface Analysis","text":"<p>Portalis has the following attack surfaces that require security controls:</p> <p>External Attack Surfaces: - API Endpoints: REST API for translation requests - Container Images: Docker images pulled from registries - Network Ingress: HTTP/HTTPS traffic from clients - WebAssembly Modules: User-provided WASM code execution - File Upload: Source code file uploads for translation</p> <p>Internal Attack Surfaces: - Inter-service Communication: Agent-to-agent communication - Database Access: Persistent data storage - Logging System: Structured log collection - Monitoring Endpoints: Prometheus metrics, health checks - Admin API: Privileged operations</p> <p>Infrastructure Attack Surfaces: - Kubernetes API: Cluster management - Container Runtime: Docker/containerd - GPU Access: CUDA workloads via NVIDIA DGX - Storage Volumes: Persistent and ephemeral volumes</p>"},{"location":"security/#stride-threat-categories","title":"STRIDE Threat Categories","text":"<p>Analysis of threats using the STRIDE methodology:</p> Category Threat Mitigation Spoofing Attacker impersonates legitimate user API key authentication, mTLS for inter-service communication Tampering Modification of data in transit TLS 1.3 encryption, integrity checks, signed artifacts Repudiation User denies performing action Comprehensive audit logging (see logging.rs) Information Disclosure Unauthorized data access Encryption at rest, WASM memory isolation, network segmentation Denial of Service Resource exhaustion attacks Rate limiting, resource quotas, timeout enforcement Elevation of Privilege Unauthorized privilege escalation RBAC, non-root containers, capability dropping, WASM sandboxing"},{"location":"security/#risk-assessment-matrix","title":"Risk Assessment Matrix","text":"<p>Likelihood x Impact = Risk Level</p> Risk Likelihood Impact Priority Mitigation Status Malicious WASM code execution High Critical P0 Mitigated (sandboxing) API credential compromise Medium High P1 Mitigated (rotation, encryption) Container escape Low Critical P1 Mitigated (runtime security) DDoS attack Medium Medium P2 Partial (rate limiting) Dependency vulnerability High Medium P2 Mitigated (automated scanning) Insider threat Low High P2 Partial (audit logging, RBAC) Supply chain attack Medium High P1 Mitigated (SBOM, image scanning) <p>Risk Levels: - P0 (Critical): Immediate action required - P1 (High): Address within 1 week - P2 (Medium): Address within 1 month - P3 (Low): Address in next planning cycle</p>"},{"location":"security/#wasm-sandboxing","title":"WASM Sandboxing","text":"<p>WebAssembly provides strong isolation for untrusted code execution, critical for translating user-provided code.</p>"},{"location":"security/#capability-based-security-model","title":"Capability-Based Security Model","text":"<p>Portalis uses WASI (WebAssembly System Interface) with strict capability controls:</p> <p>Default Denied Capabilities: - File system access (read/write) - Network socket creation - Process spawning - System calls - Signal handling</p> <p>Explicitly Granted Capabilities (minimal): <pre><code>// WASM module initialization with restricted capabilities\nuse wasmtime::*;\n\nlet engine = Engine::default();\nlet mut linker = Linker::new(&amp;engine);\n\n// Grant only stdio capabilities\nwasmtime_wasi::add_to_linker(&amp;mut linker, |s| s)?;\n\nlet wasi = WasiCtxBuilder::new()\n    .inherit_stdout()  // Allow stdout for results\n    .inherit_stderr()  // Allow stderr for errors\n    // No filesystem preopens\n    // No network sockets\n    // No environment variables\n    .build();\n</code></pre></p> <p>Capability Verification: - All WASI calls are intercepted and validated - Attempts to access restricted capabilities fail gracefully - Violations are logged for security monitoring</p>"},{"location":"security/#memory-isolation-details","title":"Memory Isolation Details","text":"<p>Linear Memory Bounds: - Each WASM module has isolated linear memory (max 4GB) - Memory is not shared between modules - Out-of-bounds access triggers immediate trap</p> <p>Memory Limits Enforced: <pre><code>// Memory configuration per WASM module\nlet memory_type = MemoryType::new(\n    1,      // Initial: 1 page (64KB)\n    Some(256), // Maximum: 256 pages (16MB)\n);\n\n// Enforce limits in wasmtime\nlet mut config = Config::new();\nconfig.max_wasm_stack(512 * 1024);  // 512KB stack\nconfig.allocation_strategy(InstanceAllocationStrategy::Pooling {\n    strategy: PoolingAllocationStrategy::default(),\n    module_limits: ModuleLimits {\n        memory_pages: 256,\n        table_elements: 1000,\n        ..Default::default()\n    },\n});\n</code></pre></p> <p>Memory Safety: - No pointer arithmetic outside module memory - Host memory is completely inaccessible - Stack overflow protection via guard pages</p>"},{"location":"security/#system-call-restrictions","title":"System Call Restrictions","text":"<p>Blocked System Calls: - <code>open</code>, <code>read</code>, <code>write</code> (file operations) - <code>socket</code>, <code>bind</code>, <code>connect</code> (networking) - <code>fork</code>, <code>exec</code> (process creation) - <code>ioctl</code>, <code>fcntl</code> (device control) - <code>ptrace</code>, <code>mmap</code> (debugging/memory manipulation)</p> <p>Allowed Operations: - Pure computation (arithmetic, logic) - Memory allocation within limits - Stdout/stderr writes (rate limited) - Controlled exits</p> <p>Seccomp-BPF Filter (additional layer): <pre><code># Seccomp profile for WASM runtime\napiVersion: v1\nkind: Pod\nspec:\n  securityContext:\n    seccompProfile:\n      type: Localhost\n      localhostProfile: wasm-restricted.json\n</code></pre></p>"},{"location":"security/#resource-limits","title":"Resource Limits","text":"<p>CPU Time Limits: <pre><code>// Fuel-based execution limits (wasmtime)\nlet mut config = Config::new();\nconfig.consume_fuel(true);\n\nlet mut store = Store::new(&amp;engine, wasi);\nstore.add_fuel(10_000_000)?;  // 10M instructions\n\n// Trap if fuel exhausted\ninstance.get_typed_func::&lt;(), ()&gt;(&amp;mut store, \"run\")\n    .call(&amp;mut store, ())\n    .map_err(|e| \"Execution timeout\")?;\n</code></pre></p> <p>Memory Limits (enforced at multiple layers): - WASM module memory: 16MB max - Container memory: 512MB max - Kubernetes pod memory: 1GB max</p> <p>Execution Timeout: - Per-function timeout: 30 seconds - Total translation timeout: 5 minutes - Idle timeout: 1 minute</p> <p>Rate Limits: - System calls: 1000/second - Memory allocations: 100/second - Stdout/stderr writes: 10KB/second</p>"},{"location":"security/#container-security","title":"Container Security","text":""},{"location":"security/#image-scanning","title":"Image Scanning","text":"<p>Trivy Integration (automated in CI/CD):</p> <p>Our security workflow runs comprehensive image scanning:</p> <pre><code># Scan filesystem for vulnerabilities\ntrivy fs --severity CRITICAL,HIGH,MEDIUM .\n\n# Scan Docker images before deployment\ntrivy image --severity CRITICAL,HIGH portalis:latest\n\n# Scan for secrets in repository\ntrivy repo --scanners secret .\n</code></pre> <p>Automated Scanning Schedule: - Pull request: All CRITICAL and HIGH findings block merge - Daily: Full security scan of all images - Release: Complete SBOM generation + vulnerability report</p> <p>Scan Results: <pre><code># Example Trivy output integration\n- name: Upload Trivy results to GitHub Security\n  uses: github/codeql-action/upload-sarif@v3\n  with:\n    sarif_file: 'trivy-results.sarif'\n</code></pre></p> <p>Vulnerability Remediation SLA: - CRITICAL: Patch within 24 hours - HIGH: Patch within 7 days - MEDIUM: Patch within 30 days - LOW: Address in next release</p>"},{"location":"security/#runtime-security","title":"Runtime Security","text":"<p>Non-Root Containers (mandatory): <pre><code>FROM rust:1.75 as builder\nWORKDIR /app\nCOPY . .\nRUN cargo build --release\n\nFROM debian:bookworm-slim\n# Create unprivileged user\nRUN groupadd -r portalis --gid=1000 &amp;&amp; \\\n    useradd -r -g portalis --uid=1000 --shell=/bin/false portalis\n\n# Install runtime dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    ca-certificates \\\n    libssl3 \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\nWORKDIR /app\nCOPY --from=builder /app/target/release/portalis /app/\n\n# Set ownership\nRUN chown -R portalis:portalis /app\n\n# Drop to unprivileged user\nUSER portalis:portalis\n\nENTRYPOINT [\"/app/portalis\"]\n</code></pre></p> <p>Security Context (Kubernetes): <pre><code>apiVersion: v1\nkind: Pod\nmetadata:\n  name: portalis-transpiler\nspec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 1000\n    runAsGroup: 1000\n    fsGroup: 1000\n    seccompProfile:\n      type: RuntimeDefault\n  containers:\n  - name: transpiler\n    image: portalis/transpiler:latest\n    securityContext:\n      allowPrivilegeEscalation: false\n      readOnlyRootFilesystem: true\n      capabilities:\n        drop:\n          - ALL\n      privileged: false\n    resources:\n      limits:\n        memory: \"1Gi\"\n        cpu: \"2000m\"\n      requests:\n        memory: \"512Mi\"\n        cpu: \"1000m\"\n    volumeMounts:\n    - name: tmp\n      mountPath: /tmp\n      readOnly: false\n  volumes:\n  - name: tmp\n    emptyDir: {}\n</code></pre></p> <p>AppArmor/SELinux Profiles: <pre><code># AppArmor profile annotation\nmetadata:\n  annotations:\n    container.apparmor.security.beta.kubernetes.io/transpiler: localhost/portalis-restricted\n</code></pre></p> <p>Runtime Monitoring: - Process monitoring (Falco) - Network connection tracking - File access auditing - Anomaly detection</p>"},{"location":"security/#network-policies","title":"Network Policies","text":"<p>Kubernetes Network Policies (default deny):</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: portalis-network-policy\n  namespace: portalis-deployment\nspec:\n  podSelector:\n    matchLabels:\n      app: portalis\n  policyTypes:\n  - Ingress\n  - Egress\n\n  # Ingress: Allow only from nginx-ingress\n  ingress:\n  - from:\n    - podSelector:\n        matchLabels:\n          app: nginx-ingress\n    ports:\n    - protocol: TCP\n      port: 8080\n\n  # Egress: Allow DNS, Triton, monitoring\n  egress:\n  - to:\n    - namespaceSelector:\n        matchLabels:\n          name: kube-system\n    ports:\n    - protocol: UDP\n      port: 53  # DNS\n  - to:\n    - podSelector:\n        matchLabels:\n          app: triton-server\n    ports:\n    - protocol: TCP\n      port: 8000  # Triton HTTP\n    - protocol: TCP\n      port: 8001  # Triton metrics\n  - to:\n    - podSelector:\n        matchLabels:\n          app: prometheus\n    ports:\n    - protocol: TCP\n      port: 9090\n</code></pre> <p>Service Mesh (Istio): <pre><code>apiVersion: security.istio.io/v1beta1\nkind: PeerAuthentication\nmetadata:\n  name: portalis-mtls\n  namespace: portalis-deployment\nspec:\n  mtls:\n    mode: STRICT  # Require mTLS for all traffic\n</code></pre></p> <p>TLS Encryption: - All HTTP traffic encrypted with TLS 1.3 - Certificate management via cert-manager - Automatic certificate renewal (Let's Encrypt) - HSTS headers enabled</p>"},{"location":"security/#secrets-management","title":"Secrets Management","text":"<p>Kubernetes Secrets (encrypted at rest):</p> <p>See secrets.yaml example for reference.</p> <pre><code># Create secrets from literal values\nkubectl create secret generic portalis-secrets \\\n  --namespace=portalis-deployment \\\n  --from-literal=api-key=$(openssl rand -base64 32) \\\n  --from-literal=db-password=$(openssl rand -base64 32) \\\n  --from-literal=jwt-secret=$(openssl rand -base64 32)\n\n# Create secrets from files\nkubectl create secret generic portalis-tls \\\n  --namespace=portalis-deployment \\\n  --from-file=tls.crt=/path/to/cert.pem \\\n  --from-file=tls.key=/path/to/key.pem\n</code></pre> <p>External Secrets Operator (recommended for production):</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: SecretStore\nmetadata:\n  name: vault-backend\n  namespace: portalis-deployment\nspec:\n  provider:\n    vault:\n      server: \"https://vault.portalis.internal:8200\"\n      path: \"secret\"\n      version: \"v2\"\n      auth:\n        kubernetes:\n          mountPath: \"kubernetes\"\n          role: \"portalis-role\"\n---\napiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: portalis-api-keys\n  namespace: portalis-deployment\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: vault-backend\n    kind: SecretStore\n  target:\n    name: portalis-secrets\n    creationPolicy: Owner\n  data:\n  - secretKey: api-key\n    remoteRef:\n      key: secret/portalis/api\n      property: key\n</code></pre> <p>Supported Secret Backends: - HashiCorp Vault: Enterprise secret management - AWS Secrets Manager: AWS-native secrets - Azure Key Vault: Azure-native secrets - Google Secret Manager: GCP-native secrets - Sealed Secrets: GitOps-friendly encrypted secrets</p> <p>Secret Rotation: - API keys: Rotate every 90 days - Database passwords: Rotate every 60 days - TLS certificates: Automatic renewal 30 days before expiry - JWT secrets: Rotate every 180 days</p> <p>Secret Access Audit: <pre><code># View secret access logs\nkubectl logs -n portalis-deployment -l app=portalis --since=24h | \\\n  grep \"secret_access\" | \\\n  jq '.user_id, .secret_name, .timestamp'\n</code></pre></p>"},{"location":"security/#security-testing","title":"Security Testing","text":""},{"location":"security/#sast-static-application-security-testing","title":"SAST (Static Application Security Testing)","text":"<p>Automated SAST Tools:</p> <ol> <li> <p>Cargo Clippy (Rust linter with security checks): <pre><code>cargo clippy --all-targets --all-features -- \\\n  -W clippy::all \\\n  -W clippy::pedantic \\\n  -W clippy::nursery \\\n  -W clippy::cargo\n</code></pre></p> </li> <li> <p>Cargo Audit (dependency vulnerability scanning): <pre><code># Automated daily via security.yml workflow\ncargo audit --json &gt; audit-report.json\ncargo audit --deny warnings\n</code></pre></p> </li> <li> <p>Semgrep (pattern-based code analysis): <pre><code>semgrep --config=auto --json --output=semgrep-report.json .\n</code></pre></p> </li> </ol> <p>SAST in CI/CD: - Run on every pull request - Block merge on HIGH/CRITICAL findings - Generate SARIF reports for GitHub Security</p>"},{"location":"security/#dast-dynamic-application-security-testing","title":"DAST (Dynamic Application Security Testing)","text":"<p>OWASP ZAP (automated penetration testing):</p> <pre><code># Baseline scan\ndocker run -t owasp/zap2docker-stable zap-baseline.py \\\n  -t https://api.portalis.dev \\\n  -r zap-report.html\n\n# Full scan with authentication\ndocker run -t owasp/zap2docker-stable zap-full-scan.py \\\n  -t https://api.portalis.dev \\\n  -c zap-config.yaml \\\n  -r zap-full-report.html\n</code></pre> <p>API Security Testing: - SQL injection testing - XSS vulnerability scanning - Authentication bypass attempts - Authorization checks - Rate limiting validation - Input fuzzing</p> <p>Testing Schedule: - Baseline DAST: Weekly - Full DAST: Monthly - Post-deployment: After major releases</p>"},{"location":"security/#dependency-scanning","title":"Dependency Scanning","text":"<p>Cargo Audit (automated via security.yml):</p> <pre><code># Check for known vulnerabilities\ncargo audit\n\n# Generate detailed report\ncargo audit --json &gt; vulnerability-report.json\n\n# Check against RustSec Advisory Database\ncargo audit --db ~/.cargo/advisory-db\n</code></pre> <p>Cargo Deny (license and security policy enforcement):</p> <pre><code># Check for security advisories\ncargo deny check advisories\n\n# Validate licenses\ncargo deny check licenses\n\n# Detect duplicate dependencies\ncargo deny check bans\n\n# Verify dependency sources\ncargo deny check sources\n</code></pre> <p>Dependabot (automated dependency updates): <pre><code># .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: \"cargo\"\n    directory: \"/\"\n    schedule:\n      interval: \"weekly\"\n    open-pull-requests-limit: 10\n    labels:\n      - \"dependencies\"\n      - \"security\"\n</code></pre></p> <p>SBOM (Software Bill of Materials): <pre><code># Generate SPDX format\ncargo sbom &gt; sbom-spdx.json\n\n# Generate CycloneDX format\ncargo cyclonedx &gt; sbom-cyclonedx.xml\n\n# Verify SBOM integrity\ncosign verify-blob --signature sbom.sig --key cosign.pub sbom-spdx.json\n</code></pre></p>"},{"location":"security/#penetration-testing-guidelines","title":"Penetration Testing Guidelines","text":"<p>Pre-Engagement: 1. Define scope (IP ranges, domains, services) 2. Establish rules of engagement 3. Set testing window 4. Identify emergency contacts</p> <p>Testing Methodology: - Reconnaissance and information gathering - Vulnerability assessment - Exploitation (with approval) - Post-exploitation (privilege escalation) - Reporting and remediation</p> <p>Approved Testing Tools: - Nmap (network scanning) - Burp Suite (web application testing) - Metasploit (exploitation framework) - sqlmap (SQL injection testing) - Nuclei (vulnerability scanner)</p> <p>Out of Scope (prohibited): - Social engineering attacks - Physical security testing - DoS/DDoS attacks - Third-party systems - Production data modification</p> <p>Penetration Testing Schedule: - External pentest: Annually - Internal pentest: Bi-annually - Web application pentest: Quarterly - Post-incident: After security incidents</p>"},{"location":"security/#security-regression-testing","title":"Security Regression Testing","text":"<p>Automated Security Test Suite:</p> <pre><code>// Security regression tests\n#[cfg(test)]\nmod security_tests {\n    use super::*;\n\n    #[test]\n    fn test_api_authentication_required() {\n        // Ensure unauthenticated requests are rejected\n        let response = client.get(\"/api/v1/translate\").send().unwrap();\n        assert_eq!(response.status(), StatusCode::UNAUTHORIZED);\n    }\n\n    #[test]\n    fn test_sql_injection_prevention() {\n        // Test SQL injection attempts are blocked\n        let payload = \"'; DROP TABLE users; --\";\n        let response = client.post(\"/api/v1/search\")\n            .json(&amp;json!({\"query\": payload}))\n            .send().unwrap();\n        assert_ne!(response.status(), StatusCode::INTERNAL_SERVER_ERROR);\n    }\n\n    #[test]\n    fn test_path_traversal_prevention() {\n        // Test path traversal attempts are blocked\n        let response = client.get(\"/api/v1/files/../../etc/passwd\").send().unwrap();\n        assert_eq!(response.status(), StatusCode::BAD_REQUEST);\n    }\n\n    #[test]\n    fn test_xss_sanitization() {\n        // Test XSS payloads are sanitized\n        let payload = \"&lt;script&gt;alert('XSS')&lt;/script&gt;\";\n        let response = client.post(\"/api/v1/comment\")\n            .json(&amp;json!({\"text\": payload}))\n            .send().unwrap();\n        let body = response.text().unwrap();\n        assert!(!body.contains(\"&lt;script&gt;\"));\n    }\n}\n</code></pre> <p>Regression Test Categories: - Authentication and authorization - Input validation and sanitization - Cryptographic operations - Session management - Error handling (no sensitive data leaks) - Security headers (CSP, HSTS, X-Frame-Options)</p>"},{"location":"security/#vulnerability-management","title":"Vulnerability Management","text":""},{"location":"security/#reporting-process","title":"Reporting Process","text":"<p>DO NOT create public GitHub issues for security vulnerabilities.</p> <p>Reporting Channels:</p> <ol> <li>Email (preferred): security@portalis.dev</li> <li>PGP key: https://portalis.dev/security.asc</li> <li> <p>Expected response: 24 hours</p> </li> <li> <p>GitHub Security Advisories:</p> </li> <li>Navigate to: https://github.com/portalis/portalis/security/advisories</li> <li>Click \"Report a vulnerability\"</li> <li> <p>Fill out vulnerability details</p> </li> <li> <p>Bug Bounty Program (coming Q2 2026):</p> </li> <li>Scope and rewards: https://portalis.dev/security/bounty</li> <li>Managed via HackerOne</li> </ol> <p>Required Information: - Vulnerability description - Steps to reproduce - Proof of concept (if available) - Impact assessment - Affected versions - Suggested remediation (optional)</p>"},{"location":"security/#response-slas","title":"Response SLAs","text":"<p>Acknowledgment: - Target: Within 24 hours - Action: Confirm receipt and assign tracking ID</p> <p>Initial Assessment: - Target: Within 72 hours - Action: Severity classification, impact analysis</p> <p>Remediation Timeline (from initial assessment):</p> Severity Description Response Time Patch Deployment Critical Remote code execution, data breach 24 hours 48 hours High Privilege escalation, authentication bypass 7 days 14 days Medium DoS, information disclosure 30 days 60 days Low Minor security improvements 90 days Next release <p>Status Updates: - Critical: Daily updates - High: Weekly updates - Medium/Low: Bi-weekly updates</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p>Coordinated Disclosure: 1. Researcher reports vulnerability privately 2. Portalis confirms and assesses severity 3. Patch developed and tested 4. Security advisory prepared 5. Patch released to customers 6. Public disclosure after 90 days (or earlier if agreed)</p> <p>Public Disclosure Timeline: - Preferred: 90 days after initial report - Minimum: After patch is available (no earlier than 30 days) - Maximum: 120 days (even if patch not ready)</p> <p>Security Advisory Format: <pre><code># Security Advisory: PORTALIS-2025-001\n\n**Severity**: HIGH\n**CVE**: CVE-2025-XXXXX\n**Affected Versions**: 1.0.0 - 1.2.3\n**Fixed Version**: 1.2.4\n\n## Summary\nBrief description of vulnerability.\n\n## Impact\nWhat an attacker could achieve.\n\n## Affected Components\n- Component A (versions X.Y.Z)\n- Component B (versions X.Y.Z)\n\n## Remediation\n- Upgrade to version 1.2.4 or later\n- Apply workaround (if applicable)\n\n## Credit\nSecurity researcher name (if public disclosure approved)\n</code></pre></p>"},{"location":"security/#cve-assignment-process","title":"CVE Assignment Process","text":"<p>CVE Numbering Authority: Portalis is pursuing CNA status (Q2 2026).</p> <p>Current Process (via GitHub): 1. Report vulnerability to security@portalis.dev 2. Portalis requests CVE via GitHub CNA 3. CVE assigned within 72 hours 4. CVE published with security advisory</p> <p>CVE Metadata: - CVSS v3.1 score - CWE classification - Affected products and versions - References and credits</p>"},{"location":"security/#incident-response","title":"Incident Response","text":""},{"location":"security/#incident-classification","title":"Incident Classification","text":"<p>Severity Levels:</p> Level Definition Examples Response Time P0 - Critical Active exploitation, data breach RCE exploit in production, customer data leaked Immediate (15 min) P1 - High Confirmed vulnerability, high risk Authentication bypass discovered, unpatched critical CVE 1 hour P2 - Medium Potential security issue Failed login attempts spike, suspicious API usage 4 hours P3 - Low Security concern, low risk Policy violation, expired certificate warning 24 hours <p>Incident Types: - Intrusion (unauthorized access) - Malware infection - Data breach - Denial of service - Insider threat - Supply chain compromise</p>"},{"location":"security/#response-procedures","title":"Response Procedures","text":"<p>Incident Response Team: - Incident Commander: Security Lead - Technical Lead: Engineering Manager - Communications Lead: Product Manager - Legal: General Counsel - On-call: Rotating SRE</p> <p>Response Workflow:</p> <ol> <li>Detection and Reporting (0-15 minutes):</li> <li>Automated monitoring alerts</li> <li>Security team notification</li> <li> <p>Incident tracking ticket created</p> </li> <li> <p>Initial Assessment (15-30 minutes):</p> </li> <li>Verify incident validity</li> <li>Classify severity (P0-P3)</li> <li>Assemble response team</li> <li> <p>Activate communication channels</p> </li> <li> <p>Containment (30 minutes - 4 hours):    <pre><code># Example containment actions\n\n# Isolate affected pods\nkubectl cordon node-xyz\nkubectl drain node-xyz --ignore-daemonsets\n\n# Revoke compromised credentials\nkubectl delete secret compromised-api-key\n\n# Enable enhanced logging\nkubectl set env deployment/portalis LOG_LEVEL=DEBUG\n\n# Block malicious IPs\nkubectl apply -f emergency-network-policy.yaml\n</code></pre></p> </li> <li> <p>Eradication (4-24 hours):</p> </li> <li>Remove malware/backdoors</li> <li>Patch vulnerabilities</li> <li>Reset compromised credentials</li> <li> <p>Rebuild affected systems</p> </li> <li> <p>Recovery (24-72 hours):</p> </li> <li>Restore services from clean backups</li> <li>Verify system integrity</li> <li>Monitor for reinfection</li> <li> <p>Gradual traffic restoration</p> </li> <li> <p>Post-Incident Activities (1 week):</p> </li> <li>Root cause analysis</li> <li>Post-mortem report</li> <li>Process improvements</li> <li>Security control updates</li> </ol>"},{"location":"security/#communication-plan","title":"Communication Plan","text":"<p>Internal Communication: - Slack: #security-incidents (immediate) - Email: security-team@portalis.dev - PagerDuty: Automated escalation - Status Page: https://status.portalis.dev</p> <p>External Communication:</p> Stakeholder Notification Timing Channel Affected customers Within 4 hours Email, in-app notification All customers Within 24 hours (if widespread) Email, status page Public Within 72 hours (if data breach) Blog post, security advisory Regulators Within 72 hours (GDPR) Official notification <p>Communication Templates: - Initial notification (facts only) - Status updates (every 4 hours for P0) - Resolution notification - Post-mortem summary</p>"},{"location":"security/#post-mortem-process","title":"Post-Mortem Process","text":"<p>Post-Mortem Document (blameless):</p> <pre><code># Incident Post-Mortem: [Title]\n\n**Date**: 2025-XX-XX\n**Duration**: X hours\n**Severity**: P0/P1/P2/P3\n**Status**: Resolved\n\n## Summary\nOne-paragraph summary of incident.\n\n## Timeline\n- 00:00 - Detection: Alert triggered\n- 00:15 - Response: Team assembled\n- 00:30 - Containment: Services isolated\n- 04:00 - Eradication: Vulnerability patched\n- 24:00 - Recovery: Services restored\n\n## Root Cause\nTechnical explanation of what went wrong.\n\n## Impact\n- Affected users: X\n- Duration: X hours\n- Data exposed: Yes/No\n- Revenue impact: $X\n\n## What Went Well\n- Positive aspects of response\n\n## What Went Wrong\n- Areas needing improvement\n\n## Action Items\n- [ ] Action 1 (Owner: @user, Due: 2025-XX-XX)\n- [ ] Action 2 (Owner: @user, Due: 2025-XX-XX)\n\n## Lessons Learned\nKey takeaways for future incidents.\n</code></pre> <p>Post-Mortem Meeting: - Scheduled within 1 week of resolution - All stakeholders attend - Blameless culture - Focus on process improvements</p>"},{"location":"security/#compliance-auditing","title":"Compliance &amp; Auditing","text":""},{"location":"security/#audit-logging","title":"Audit Logging","text":"<p>Portalis implements comprehensive audit logging using the structured logging framework in core/src/logging.rs.</p> <p>Audit Log Events:</p> <pre><code>// AuditLogger usage examples\nuse portalis_core::logging::AuditLogger;\n\n// Translation request\nAuditLogger::log_translation_request(\n    \"user-123\",\n    \"fibonacci.py\",\n    \"192.168.1.100\"\n);\n\n// Translation completion\nAuditLogger::log_translation_complete(\n    \"user-123\",\n    \"trans-456\",\n    true  // success\n);\n\n// Error events\nAuditLogger::log_error(\n    \"user-123\",\n    \"AuthenticationFailure\",\n    \"Invalid API key provided\"\n);\n</code></pre> <p>Audit Log Format (JSON): <pre><code>{\n  \"timestamp\": \"2025-10-03T14:23:45.123Z\",\n  \"event_type\": \"translation_request\",\n  \"user_id\": \"user-123\",\n  \"source_file\": \"fibonacci.py\",\n  \"ip_address\": \"192.168.1.100\",\n  \"trace_id\": \"trace-abc-123\",\n  \"session_id\": \"sess-xyz-789\",\n  \"user_agent\": \"portalis-cli/1.2.0\",\n  \"result\": \"success\"\n}\n</code></pre></p> <p>Audit Log Categories: - Authentication events (login, logout, failed attempts) - Authorization events (permission grants, denials) - Data access (read, write, delete) - Configuration changes - Administrative actions - Security events (alerts, policy violations)</p> <p>Log Retention: - Hot storage (Elasticsearch): 90 days - Warm storage (S3): 1 year - Cold storage (S3 Glacier): 7 years (compliance)</p> <p>Log Integrity: - Logs signed with HMAC-SHA256 - Write-once, read-many (WORM) storage - Tamper detection via checksums</p>"},{"location":"security/#access-controls","title":"Access Controls","text":"<p>Role-Based Access Control (RBAC):</p> <pre><code>apiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: portalis-deployment\n  name: portalis-developer\nrules:\n- apiGroups: [\"\"]\n  resources: [\"pods\", \"pods/log\"]\n  verbs: [\"get\", \"list\", \"watch\"]\n- apiGroups: [\"apps\"]\n  resources: [\"deployments\"]\n  verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: Role\nmetadata:\n  namespace: portalis-deployment\n  name: portalis-admin\nrules:\n- apiGroups: [\"*\"]\n  resources: [\"*\"]\n  verbs: [\"*\"]\n</code></pre> <p>Principle of Least Privilege: - Users granted minimum required permissions - Time-limited elevated access (JIT) - Regular access reviews (quarterly)</p> <p>Multi-Factor Authentication (MFA): - Required for all admin access - TOTP (Google Authenticator, Authy) - Hardware tokens (YubiKey) for production</p>"},{"location":"security/#data-retention","title":"Data Retention","text":"<p>Retention Policies:</p> Data Type Retention Period Purpose Storage Translation requests 30 days Service delivery PostgreSQL Audit logs 7 years Compliance (SOC2) S3 + Glacier System metrics 90 days Monitoring Prometheus Application logs 90 days Debugging Elasticsearch Backups 30 days Disaster recovery S3 User data Until deletion Service provision PostgreSQL <p>Automated Deletion: <pre><code># Cron job for data retention enforcement\n0 2 * * * /usr/local/bin/portalis-cleanup \\\n  --delete-translations-older-than 30d \\\n  --archive-logs-older-than 90d \\\n  --delete-temp-files\n</code></pre></p> <p>Legal Holds: - Retention extended for litigation - Flagged data excluded from automated deletion - Documented in legal hold register</p>"},{"location":"security/#compliance-frameworks","title":"Compliance Frameworks","text":"<p>SOC 2 Type II: - Trust Service Criteria: Security, Availability, Confidentiality - Control Activities: See compliance.md - Evidence: Audit logs, access reviews, change logs - Status: In progress (Q3 2026)</p> <p>ISO 27001: - Information Security Management System (ISMS) - Risk Assessment: Annual review - Statement of Applicability (SOA): 114 controls - Status: Planned (2026)</p> <p>GDPR: - Data Processing Agreement (DPA): Available for customers - Privacy by Design: Minimal data collection - Data Subject Rights: Export, deletion, portability - Status: Compliant</p> <p>NIST Cybersecurity Framework: - Identify: Asset inventory, risk assessment - Protect: Access controls, encryption - Detect: Monitoring, logging - Respond: Incident response plan - Recover: Backup and disaster recovery</p> <p>Compliance Artifacts: - Security policies and procedures - Risk assessment reports - Penetration test reports - Audit logs and access reviews - Vendor security questionnaires - Security training records</p>"},{"location":"security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"security/#operational-security","title":"Operational Security","text":"<ol> <li>Keep Software Updated:</li> <li>Automated dependency updates (Dependabot)</li> <li>Security patches applied within SLA</li> <li> <p>Kubernetes cluster auto-upgrade enabled</p> </li> <li> <p>Principle of Least Privilege:</p> </li> <li>Minimal container capabilities</li> <li>RBAC for all access</li> <li> <p>Time-limited elevated permissions</p> </li> <li> <p>Defense in Depth:</p> </li> <li>Multiple security layers (WASM, container, network, cluster)</li> <li>No single point of failure</li> <li> <p>Redundant security controls</p> </li> <li> <p>Input Validation:</p> </li> <li>Whitelist allowed inputs</li> <li>Sanitize all user data</li> <li> <p>Reject malformed requests early</p> </li> <li> <p>Secure Defaults:</p> </li> <li>TLS enabled by default</li> <li>Authentication required</li> <li>Minimal exposed services</li> </ol>"},{"location":"security/#development-security","title":"Development Security","text":"<ol> <li>Secure Coding Practices:</li> <li>Avoid unsafe Rust code</li> <li>Use parameterized queries (no SQL injection)</li> <li> <p>Validate all inputs at API boundary</p> </li> <li> <p>Code Review:</p> </li> <li>Security-focused code reviews</li> <li>Automated SAST in CI/CD</li> <li> <p>Peer review required for all changes</p> </li> <li> <p>Dependency Management:</p> </li> <li>Pin dependency versions</li> <li>Regular updates for security patches</li> <li> <p>Audit third-party libraries</p> </li> <li> <p>Secrets Management:</p> </li> <li>Never commit secrets to version control</li> <li>Use environment variables or secret managers</li> <li> <p>Rotate secrets regularly</p> </li> <li> <p>Security Testing:</p> </li> <li>Unit tests for security controls</li> <li>Integration tests for authentication/authorization</li> <li>Regular penetration testing</li> </ol>"},{"location":"security/#deployment-security","title":"Deployment Security","text":"<ol> <li>Infrastructure as Code:</li> <li>Version-controlled infrastructure (Terraform, Kubernetes YAML)</li> <li>Code review for infrastructure changes</li> <li> <p>Automated deployment pipelines</p> </li> <li> <p>Immutable Infrastructure:</p> </li> <li>Rebuild containers instead of patching</li> <li>No SSH access to production containers</li> <li> <p>Ephemeral workloads</p> </li> <li> <p>Monitoring and Alerting:</p> </li> <li>Security metrics (failed logins, policy violations)</li> <li>Real-time alerting (PagerDuty)</li> <li> <p>Log aggregation and analysis</p> </li> <li> <p>Backup and Disaster Recovery:</p> </li> <li>Regular automated backups</li> <li>Tested restore procedures</li> <li> <p>Offsite backup storage</p> </li> <li> <p>Access Control:</p> </li> <li>MFA for all production access</li> <li>VPN or bastion hosts for infrastructure access</li> <li>Audit all privileged operations</li> </ol>"},{"location":"security/#reporting-security-issues","title":"Reporting Security Issues","text":"<p>DO NOT create public GitHub issues for security vulnerabilities.</p>"},{"location":"security/#responsible-disclosure","title":"Responsible Disclosure","text":"<p>We appreciate security researchers who report vulnerabilities responsibly. Please follow these guidelines:</p> <ol> <li>Do Not exploit the vulnerability beyond proof of concept</li> <li>Do Not access, modify, or delete customer data</li> <li>Do Not perform destructive testing (DoS, data corruption)</li> <li>Do provide detailed reproduction steps</li> <li>Do allow reasonable time for remediation before public disclosure</li> </ol>"},{"location":"security/#contact-information","title":"Contact Information","text":"<p>Primary Contact: - Email: security@portalis.dev - PGP Key: https://portalis.dev/security.asc (Fingerprint: XXXX XXXX XXXX XXXX) - Response Time: Within 24 hours</p> <p>GitHub Security Advisories: - https://github.com/portalis/portalis/security/advisories - Click \"Report a vulnerability\" - Use for structured vulnerability reports</p> <p>Escalation (if no response within 48 hours): - CTO: cto@portalis.dev - CEO: ceo@portalis.dev</p>"},{"location":"security/#bug-bounty-program","title":"Bug Bounty Program","text":"<p>Status: Coming Q2 2026</p> <p>Planned Scope: - *.portalis.dev domains - API endpoints (api.portalis.dev) - Mobile applications - Open-source repositories</p> <p>Rewards (planned): - Critical: $5,000 - $20,000 - High: $1,000 - $5,000 - Medium: $500 - $1,000 - Low: $100 - $500</p> <p>Out of Scope: - Social engineering - Physical attacks - Third-party services - Denial of service</p>"},{"location":"security/#related-documentation","title":"Related Documentation","text":"<ul> <li>Compliance: compliance.md - SOC2, GDPR, ISO 27001 compliance</li> <li>Architecture: architecture.md - System architecture and security boundaries</li> <li>Deployment: deployment/kubernetes.md - Secure deployment guidelines</li> <li>Logging: core/src/logging.rs - Audit logging implementation</li> <li>Workflows: .github/workflows/security.yml - Automated security scanning</li> </ul>"},{"location":"security/#acknowledgments","title":"Acknowledgments","text":"<p>We thank the security research community for helping keep Portalis secure. Special thanks to:</p> <ul> <li>Security researchers who have responsibly disclosed vulnerabilities</li> <li>Open-source security tools (Trivy, cargo-audit, Dependabot)</li> <li>OWASP for security best practices guidance</li> </ul> <p>Document Version: 2.0 Last Updated: 2025-10-03 Next Review: 2026-01-03 Owner: Security Team security@portalis.dev</p>"},{"location":"troubleshooting/","title":"Troubleshooting Guide","text":"<p>Common issues and solutions when using Portalis.</p>"},{"location":"troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation Issues</li> <li>Translation Errors</li> <li>GPU and CUDA Problems</li> <li>Build Failures</li> <li>WASM Runtime Issues</li> <li>Performance Problems</li> <li>Service Connectivity</li> <li>Getting Help</li> </ul>"},{"location":"troubleshooting/#installation-issues","title":"Installation Issues","text":""},{"location":"troubleshooting/#issue-cargo-install-portalis-fails","title":"Issue: <code>cargo install portalis</code> fails","text":"<p>Symptoms: <pre><code>error: failed to compile `portalis v0.1.0`\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Update Rust toolchain: <pre><code>rustup update stable\nrustc --version  # Should be 1.75+\n</code></pre></p> </li> <li> <p>Install required dependencies: <pre><code># Ubuntu/Debian\nsudo apt-get update\nsudo apt-get install build-essential pkg-config libssl-dev\n\n# macOS\nbrew install openssl pkg-config\n\n# Windows (use Visual Studio Build Tools)\n# Download from: https://visualstudio.microsoft.com/downloads/\n</code></pre></p> </li> <li> <p>Check WASM target: <pre><code>rustup target add wasm32-wasi\nrustup target list | grep wasm32-wasi\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-gpu-features-not-available","title":"Issue: GPU features not available","text":"<p>Symptoms: <pre><code>\u26a0\ufe0f  GPU acceleration: not available\n\u26a0\ufe0f  CUDA: not detected\n</code></pre></p> <p>This is normal if: - You don't have an NVIDIA GPU - CUDA is not installed - Running in CPU-only mode</p> <p>Solutions:</p> <p>Option 1: Use CPU-only mode (no action needed) - Pattern-based translation works without GPU - Suitable for development and testing</p> <p>Option 2: Install CUDA for GPU acceleration <pre><code># Check GPU\nnvidia-smi\n\n# Install CUDA 12.0+ from NVIDIA website\n# Then rebuild with GPU features\ncargo install portalis --features gpu\n</code></pre></p>"},{"location":"troubleshooting/#translation-errors","title":"Translation Errors","text":""},{"location":"troubleshooting/#issue-translation-failed-with-unsupported-python-feature","title":"Issue: Translation failed with \"Unsupported Python feature\"","text":"<p>Symptoms: <pre><code>Error: Translation failed\nReason: Unsupported feature: **kwargs at line 42\n</code></pre></p> <p>Solution: Refactor code to use supported patterns. See Python Compatibility Matrix.</p> <p>Example - Keyword Arguments: <pre><code># Unsupported\ndef configure(**kwargs):\n    pass\n\n# Workaround - use dataclass\nfrom dataclasses import dataclass\n\n@dataclass\nclass Config:\n    host: str = \"localhost\"\n    port: int = 8080\n\ndef configure(config: Config):\n    pass\n</code></pre></p>"},{"location":"troubleshooting/#issue-type-inference-failures","title":"Issue: Type inference failures","text":"<p>Symptoms: <pre><code>Error: Cannot infer type for variable 'x' at line 15\n</code></pre></p> <p>Solution: Add explicit type hints:</p> <pre><code># Before - may fail\ndef process(data):\n    result = transform(data)\n    return result\n\n# After - works\ndef process(data: List[int]) -&gt; List[int]:\n    result: List[int] = transform(data)\n    return result\n</code></pre>"},{"location":"troubleshooting/#issue-import-errors","title":"Issue: Import errors","text":"<p>Symptoms: <pre><code>Error: Cannot translate module 'custom_module'\n</code></pre></p> <p>Solution:</p> <ol> <li>Check compatibility: Ensure module is supported</li> <li> <p>Use explicit imports: Avoid wildcard imports <pre><code># Avoid\nfrom module import *\n\n# Prefer\nfrom module import specific_function, SpecificClass\n</code></pre></p> </li> <li> <p>Inline stdlib usage: Some stdlib modules have Rust equivalents <pre><code># Instead of importing datetime\nimport datetime\n\n# Use type hints that translate\nfrom datetime import datetime as DateTime\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-nemo-translation-timeout","title":"Issue: NeMo translation timeout","text":"<p>Symptoms: <pre><code>Error: NeMo service timeout after 30s\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase timeout: <pre><code>portalis translate --input large.py --timeout 60\n</code></pre></p> </li> <li> <p>Break into smaller files: <pre><code># Split large file into modules\nportalis batch --input-dir ./modules --parallel 4\n</code></pre></p> </li> <li> <p>Use pattern mode for large files: <pre><code>portalis translate --input large.py --mode pattern\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#gpu-and-cuda-problems","title":"GPU and CUDA Problems","text":""},{"location":"troubleshooting/#issue-cuda-out-of-memory","title":"Issue: CUDA out of memory","text":"<p>Symptoms: <pre><code>CUDA Error: out of memory (code: 2)\nGPU memory: 7854MB / 8192MB\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Reduce batch size: <pre><code># portalis.toml\n[gpu]\nbatch_size = 16  # Reduce from 32\n</code></pre></p> </li> <li> <p>Clear GPU cache: <pre><code># Restart translation service\ndocker-compose restart nemo-service\n</code></pre></p> </li> <li> <p>Limit GPU memory: <pre><code>[gpu]\nmemory_limit_mb = 6144  # Leave headroom\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-cuda-version-mismatch","title":"Issue: CUDA version mismatch","text":"<p>Symptoms: <pre><code>Error: CUDA 11.8 detected, but 12.0+ required\n</code></pre></p> <p>Solution: Update CUDA toolkit: <pre><code># Check current version\nnvidia-smi\n\n# Download CUDA 12.0+ from NVIDIA\n# https://developer.nvidia.com/cuda-downloads\n\n# Verify installation\nnvcc --version\n</code></pre></p>"},{"location":"troubleshooting/#issue-gpu-not-detected","title":"Issue: GPU not detected","text":"<p>Symptoms: <pre><code>portalis doctor\n\n\u26a0\ufe0f  CUDA: not detected\n\u26a0\ufe0f  GPU: not available\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check NVIDIA driver: <pre><code>nvidia-smi\n# Should show GPU info\n\n# If not, install/update driver\nsudo ubuntu-drivers autoinstall\n</code></pre></p> </li> <li> <p>Check CUDA installation: <pre><code>nvcc --version\n# Should show CUDA 12.0+\n</code></pre></p> </li> <li> <p>Set CUDA device: <pre><code>export CUDA_VISIBLE_DEVICES=0\nportalis translate --input test.py\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#build-failures","title":"Build Failures","text":""},{"location":"troubleshooting/#issue-wasm-compilation-failed","title":"Issue: WASM compilation failed","text":"<p>Symptoms: <pre><code>Error: wasm-ld: error: unknown argument: --shared-memory\n</code></pre></p> <p>Solution:</p> <ol> <li> <p>Update WASM target: <pre><code>rustup target add wasm32-wasi --force\n</code></pre></p> </li> <li> <p>Check Rust version: <pre><code>rustc --version  # Should be 1.75+\nrustup update stable\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-cannot-find-wasm-ld","title":"Issue: \"Cannot find wasm-ld\"","text":"<p>Symptoms: <pre><code>Error: linker `rust-lld` not found\n</code></pre></p> <p>Solution:</p> <pre><code># Reinstall Rust toolchain\nrustup toolchain install stable\nrustup default stable\n\n# Verify\nwhich rust-lld\n</code></pre>"},{"location":"troubleshooting/#issue-link-time-optimization-lto-errors","title":"Issue: Link-time optimization (LTO) errors","text":"<p>Symptoms: <pre><code>Error: LTO failed during linking\n</code></pre></p> <p>Solution:</p> <p>Disable LTO temporarily: <pre><code>portalis translate --input test.py --no-lto\n\n# Or in config\n# portalis.toml\n[optimization]\nlto = false\n</code></pre></p>"},{"location":"troubleshooting/#wasm-runtime-issues","title":"WASM Runtime Issues","text":""},{"location":"troubleshooting/#issue-wasm-module-instantiation-failed","title":"Issue: WASM module instantiation failed","text":"<p>Symptoms: <pre><code>Error: WebAssembly.instantiate(): Import #0 module=\"env\" error\n</code></pre></p> <p>Solution:</p> <ol> <li> <p>Check WASI compatibility: <pre><code># Use wasmtime to test\nwasmtime run output.wasm\n</code></pre></p> </li> <li> <p>Verify module exports: <pre><code>wasm-objdump -x output.wasm | grep export\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-stack-overflow-in-wasm","title":"Issue: Stack overflow in WASM","text":"<p>Symptoms: <pre><code>RuntimeError: call stack exhausted\n</code></pre></p> <p>Solution:</p> <p>Increase stack size: <pre><code># Compile with larger stack\nportalis translate --input recursive.py --stack-size 1048576\n</code></pre></p> <p>Or refactor to avoid deep recursion: <pre><code># Before - recursive\ndef factorial(n: int) -&gt; int:\n    if n &lt;= 1:\n        return 1\n    return n * factorial(n - 1)\n\n# After - iterative\ndef factorial(n: int) -&gt; int:\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n</code></pre></p>"},{"location":"troubleshooting/#performance-problems","title":"Performance Problems","text":""},{"location":"troubleshooting/#issue-slow-translation-performance","title":"Issue: Slow translation performance","text":"<p>Symptoms: <pre><code>\u23f1\ufe0f  Translation took 45.3s (expected ~5s)\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Enable GPU acceleration: <pre><code># Check if GPU is available\nportalis doctor\n\n# Use NeMo mode\nportalis translate --input slow.py --mode nemo\n</code></pre></p> </li> <li> <p>Use batch mode: <pre><code># Translate multiple files in parallel\nportalis batch --input-dir ./src --parallel 8\n</code></pre></p> </li> <li> <p>Reduce optimization level: <pre><code># For development\nportalis translate --input dev.py -O 0\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-high-memory-usage","title":"Issue: High memory usage","text":"<p>Symptoms: <pre><code>System memory: 14.2GB / 16GB\nWarning: High memory pressure\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Reduce parallelism: <pre><code>portalis batch --input-dir ./src --parallel 2\n</code></pre></p> </li> <li> <p>Process files sequentially: <pre><code>for file in src/*.py; do\n    portalis translate --input \"$file\"\ndone\n</code></pre></p> </li> <li> <p>Enable streaming mode: <pre><code>[translation]\nstreaming = true\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-low-gpu-utilization","title":"Issue: Low GPU utilization","text":"<p>Symptoms: <pre><code>GPU utilization: 15% (expected 70%+)\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase batch size: <pre><code>[gpu]\nbatch_size = 64  # Increase from 32\n</code></pre></p> </li> <li> <p>Use batch translation: <pre><code>portalis batch --input-dir ./src --mode nemo\n</code></pre></p> </li> <li> <p>Check GPU isn't throttling: <pre><code>nvidia-smi --query-gpu=temperature.gpu --format=csv\n# Temperature should be &lt;85\u00b0C\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#service-connectivity","title":"Service Connectivity","text":""},{"location":"troubleshooting/#issue-cannot-connect-to-nemo-service","title":"Issue: Cannot connect to NeMo service","text":"<p>Symptoms: <pre><code>Error: Failed to connect to NeMo service at http://localhost:8000\nConnection refused\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Start NeMo service: <pre><code># Using Docker Compose\ndocker-compose up -d nemo-service\n\n# Check status\ndocker-compose ps\n</code></pre></p> </li> <li> <p>Check service URL: <pre><code># Test connectivity\ncurl http://localhost:8000/health\n\n# Set correct URL\nexport NEMO_SERVICE_URL=http://localhost:8000\n</code></pre></p> </li> <li> <p>Check firewall: <pre><code># Allow port 8000\nsudo ufw allow 8000/tcp\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-nemo-service-crashes","title":"Issue: NeMo service crashes","text":"<p>Symptoms: <pre><code>Error: NeMo service returned 500 Internal Server Error\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check service logs: <pre><code>docker-compose logs nemo-service\n</code></pre></p> </li> <li> <p>Restart service: <pre><code>docker-compose restart nemo-service\n</code></pre></p> </li> <li> <p>Check GPU memory: <pre><code>nvidia-smi\n# Free up GPU memory if needed\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#issue-triton-inference-server-timeout","title":"Issue: Triton Inference Server timeout","text":"<p>Symptoms: <pre><code>Error: Triton request timeout after 30s\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase timeout: <pre><code>export TRITON_TIMEOUT=60\n</code></pre></p> </li> <li> <p>Check Triton health: <pre><code>curl http://localhost:8001/v2/health/ready\n</code></pre></p> </li> <li> <p>Scale Triton instances: <pre><code>kubectl scale deployment triton --replicas=3\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#debugging-techniques","title":"Debugging Techniques","text":""},{"location":"troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code># Maximum verbosity\nRUST_LOG=trace portalis translate --input debug.py\n\n# Component-specific logging\nRUST_LOG=portalis_transpiler=debug portalis translate --input debug.py\n</code></pre>"},{"location":"troubleshooting/#get-stack-traces","title":"Get Stack Traces","text":"<pre><code># Full backtrace on errors\nRUST_BACKTRACE=full portalis translate --input error.py\n\n# Colored backtrace\nRUST_BACKTRACE=1 COLORBT_SHOW_HIDDEN=1 portalis translate --input error.py\n</code></pre>"},{"location":"troubleshooting/#profile-performance","title":"Profile Performance","text":"<pre><code># Built-in profiler\nportalis translate --input slow.py --profile\n\n# Output:\n# Profiling Results:\n#   Ingest:     145ms  (12%)\n#   Analysis:   234ms  (19%)\n#   Translation: 723ms (61%)\n#   Build:      98ms   (8%)\n</code></pre>"},{"location":"troubleshooting/#inspect-intermediate-output","title":"Inspect Intermediate Output","text":"<pre><code># Save Rust code\nportalis translate --input test.py --save-rust test.rs\n\n# Keep build artifacts\nportalis translate --input test.py --preserve-artifacts\n\n# Show all intermediate steps\nportalis translate --input test.py --verbose --show-rust\n</code></pre>"},{"location":"troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"troubleshooting/#feature-nemo-not-enabled","title":"\"feature <code>nemo</code> not enabled\"","text":"<p>Cause: Trying to use NeMo without GPU features.</p> <p>Solution: <pre><code># Rebuild with GPU support\ncargo install portalis --features gpu\n\n# Or use pattern mode\nportalis translate --input test.py --mode pattern\n</code></pre></p>"},{"location":"troubleshooting/#wasm-validation-failed","title":"\"WASM validation failed\"","text":"<p>Cause: Generated WASM is invalid.</p> <p>Solution: <pre><code># Validate WASM\nwasm-validate output.wasm\n\n# Regenerate with validation\nportalis translate --input test.py --validate-wasm\n</code></pre></p>"},{"location":"troubleshooting/#type-annotation-required","title":"\"Type annotation required\"","text":"<p>Cause: Missing type hints.</p> <p>Solution: Add type annotations to all functions and variables: <pre><code>def process(items: List[str]) -&gt; Dict[str, int]:\n    result: Dict[str, int] = {}\n    for item in items:\n        result[item] = len(item)\n    return result\n</code></pre></p>"},{"location":"troubleshooting/#known-issues-and-workarounds","title":"Known Issues and Workarounds","text":""},{"location":"troubleshooting/#issue-large-file-translation-is-slow","title":"Issue: Large file translation is slow","text":"<p>Status: Known limitation</p> <p>Workaround: Split into smaller modules <pre><code># Instead of one large file (10,000+ lines)\n# Split into multiple modules\n\n# calculations.py (500 lines)\n# data_structures.py (300 lines)\n# utilities.py (200 lines)\n</code></pre></p>"},{"location":"troubleshooting/#issue-some-numpy-operations-unsupported","title":"Issue: Some NumPy operations unsupported","text":"<p>Status: Partial support</p> <p>Workaround: Use supported operations or Rust equivalents <pre><code># Instead of NumPy\nimport numpy as np\narr = np.array([1, 2, 3])\n\n# Use lists\nfrom typing import List\narr: List[int] = [1, 2, 3]\n</code></pre></p>"},{"location":"troubleshooting/#collecting-diagnostic-information","title":"Collecting Diagnostic Information","text":"<p>When reporting issues, include:</p> <pre><code># System diagnostics\nportalis doctor --verbose &gt; diagnostics.txt\n\n# Version information\nportalis version --json &gt; version.json\n\n# Translation attempt with logs\nRUST_LOG=debug portalis translate --input problematic.py 2&gt;&amp;1 | tee error.log\n\n# Environment\nenv | grep -E '(RUST|CUDA|PORTALIS)' &gt; env.txt\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"troubleshooting/#documentation","title":"Documentation","text":"<ul> <li>Getting Started</li> <li>CLI Reference</li> <li>Python Compatibility</li> <li>Performance Guide</li> </ul>"},{"location":"troubleshooting/#community-support","title":"Community Support","text":"<ul> <li>GitHub Issues: github.com/portalis/portalis/issues</li> <li>Discord: discord.gg/portalis</li> <li>Stack Overflow: Tag with <code>portalis</code></li> </ul>"},{"location":"troubleshooting/#enterprise-support","title":"Enterprise Support","text":"<ul> <li>Email: support@portalis.dev</li> <li>SLA: 24-hour response for enterprise customers</li> <li>Priority Support: Available with Enterprise license</li> </ul>"},{"location":"troubleshooting/#reporting-bugs","title":"Reporting Bugs","text":"<p>Include in bug reports: 1. Portalis version (<code>portalis version</code>) 2. Operating system and version 3. Rust version (<code>rustc --version</code>) 4. GPU information (if applicable - <code>nvidia-smi</code>) 5. Minimal reproduction case 6. Expected vs. actual behavior 7. Diagnostic information (see above)</p> <p>Bug report template: <pre><code>### Environment\n- Portalis version: 0.1.0\n- OS: Ubuntu 22.04\n- Rust: 1.75.0\n- GPU: NVIDIA RTX 4090 (if applicable)\n\n### Description\nBrief description of the issue\n\n### Reproduction\nSteps to reproduce:\n1. Create file `test.py` with...\n2. Run `portalis translate --input test.py`\n3. Error occurs\n\n### Expected Behavior\nWhat should happen\n\n### Actual Behavior\nWhat actually happens (include error messages)\n\n### Diagnostics\nAttach diagnostics.txt, error.log, version.json\n</code></pre></p>"},{"location":"troubleshooting/#faq","title":"FAQ","text":"<p>Q: Can I translate Python 2 code? A: No, only Python 3.9+ is supported. Use tools like <code>2to3</code> to upgrade.</p> <p>Q: Does Portalis support Jupyter notebooks? A: Not directly. Extract Python code from notebooks first.</p> <p>Q: Can I translate packages with dependencies? A: Yes, but dependencies must also be translated. Use <code>portalis batch</code> for projects.</p> <p>Q: Is multithreading supported? A: Python threading translates to Tokio async tasks. For true parallelism, use async/await.</p> <p>Q: Can I use Portalis in CI/CD? A: Yes! See Getting Started for examples.</p> <p>Still having issues? Join our Discord community for real-time help!</p>"},{"location":"deployment/docker-compose/","title":"Docker Compose Deployment Guide","text":"<p>Quick start guide for deploying Portalis locally with Docker Compose.</p>"},{"location":"deployment/docker-compose/#quick-start","title":"Quick Start","text":"<pre><code># Clone repository\ngit clone https://github.com/portalis/portalis.git\ncd portalis\n\n# Start all services\ndocker-compose up -d\n\n# Check status\ndocker-compose ps\n\n# View logs\ndocker-compose logs -f\n\n# Access API\ncurl http://localhost:8080/health\n</code></pre>"},{"location":"deployment/docker-compose/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   NGINX (80)     \u2502 \u2192 Load balancer\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Translation     \u2502  NeMo Service    \u2502  CUDA Parser     \u2502\n\u2502  API (3x)        \u2502  (GPU)           \u2502  (GPU)           \u2502\n\u2502  Port: 8080-8082 \u2502  Port: 8000      \u2502  Port: 8001      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2193                   \u2193                   \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Redis Cache    \u2502  Prometheus      \u2502  Grafana         \u2502\n\u2502   Port: 6379     \u2502  Port: 9090      \u2502  Port: 3000      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"deployment/docker-compose/#configuration","title":"Configuration","text":""},{"location":"deployment/docker-compose/#docker-composeyml","title":"docker-compose.yml","text":"<pre><code>version: '3.8'\n\nservices:\n  # Translation API (CPU)\n  portalis-api:\n    image: portalis/portalis:latest\n    ports:\n      - \"8080:8080\"\n    environment:\n      - RUST_LOG=info\n      - NEMO_SERVICE_URL=http://nemo:8000\n      - CUDA_SERVICE_URL=http://cuda:8001\n      - REDIS_URL=redis://redis:6379\n    depends_on:\n      - nemo\n      - redis\n    deploy:\n      replicas: 3\n      resources:\n        limits:\n          cpus: '2'\n          memory: 4G\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  # NeMo Translation Service (GPU)\n  nemo:\n    image: portalis/nemo-service:latest\n    environment:\n      - CUDA_VISIBLE_DEVICES=0\n      - MODEL_PATH=/models/nemo-translation\n    volumes:\n      - ./models:/models\n    deploy:\n      resources:\n        reservations:\n          devices:\n            - driver: nvidia\n              count: 1\n              capabilities: [gpu]\n\n  # CUDA Parsing Service (GPU)\n  cuda:\n    image: portalis/cuda-parser:latest\n    environment:\n      - CUDA_VISIBLE_DEVICES=1\n    deploy:\n      resources:\n        reservations:\n          devices:\n            - driver: nvidia\n              count: 1\n              capabilities: [gpu]\n\n  # Redis Cache\n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis-data:/data\n    command: redis-server --maxmemory 2gb --maxmemory-policy allkeys-lru\n\n  # NGINX Load Balancer\n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - portalis-api\n\n  # Prometheus Monitoring\n  prometheus:\n    image: prom/prometheus:latest\n    ports:\n      - \"9090:9090\"\n    volumes:\n      - ./prometheus.yml:/etc/prometheus/prometheus.yml\n      - prometheus-data:/prometheus\n\n  # Grafana Dashboards\n  grafana:\n    image: grafana/grafana:latest\n    ports:\n      - \"3000:3000\"\n    environment:\n      - GF_SECURITY_ADMIN_PASSWORD=admin\n    volumes:\n      - grafana-data:/var/lib/grafana\n      - ./grafana-dashboards:/etc/grafana/provisioning/dashboards\n\nvolumes:\n  redis-data:\n  prometheus-data:\n  grafana-data:\n</code></pre>"},{"location":"deployment/docker-compose/#gpu-configuration","title":"GPU Configuration","text":""},{"location":"deployment/docker-compose/#prerequisites","title":"Prerequisites","text":"<pre><code># Install NVIDIA Docker runtime\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID)\ncurl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -\ncurl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | \\\n  sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n\nsudo apt-get update &amp;&amp; sudo apt-get install -y nvidia-docker2\nsudo systemctl restart docker\n\n# Test GPU access\ndocker run --rm --gpus all nvidia/cuda:12.0-base nvidia-smi\n</code></pre>"},{"location":"deployment/docker-compose/#gpu-enabled-compose","title":"GPU-Enabled Compose","text":"<pre><code># docker-compose.gpu.yml\nversion: '3.8'\n\nservices:\n  portalis-api:\n    extends:\n      file: docker-compose.yml\n      service: portalis-api\n\n  nemo:\n    runtime: nvidia\n    environment:\n      - NVIDIA_VISIBLE_DEVICES=0\n    deploy:\n      resources:\n        reservations:\n          devices:\n            - driver: nvidia\n              count: 1\n              capabilities: [gpu]\n</code></pre>"},{"location":"deployment/docker-compose/#common-operations","title":"Common Operations","text":""},{"location":"deployment/docker-compose/#start-services","title":"Start Services","text":"<pre><code># CPU-only mode\ndocker-compose up -d\n\n# GPU-enabled mode\ndocker-compose -f docker-compose.yml -f docker-compose.gpu.yml up -d\n\n# Scale API replicas\ndocker-compose up -d --scale portalis-api=5\n</code></pre>"},{"location":"deployment/docker-compose/#monitoring","title":"Monitoring","text":"<pre><code># View logs\ndocker-compose logs -f portalis-api\ndocker-compose logs -f nemo\n\n# Check resource usage\ndocker stats\n\n# Access Grafana\nopen http://localhost:3000  # admin/admin\n</code></pre>"},{"location":"deployment/docker-compose/#maintenance","title":"Maintenance","text":"<pre><code># Update images\ndocker-compose pull\ndocker-compose up -d\n\n# Restart services\ndocker-compose restart\n\n# Stop services\ndocker-compose down\n\n# Remove volumes\ndocker-compose down -v\n</code></pre>"},{"location":"deployment/docker-compose/#environment-variables","title":"Environment Variables","text":"<p>Create <code>.env</code> file:</p> <pre><code># .env\nPORTALIS_VERSION=latest\nRUST_LOG=info\nNEMO_MODEL_PATH=./models/nemo\nREDIS_MAX_MEMORY=2gb\nPROMETHEUS_RETENTION=30d\nGRAFANA_ADMIN_PASSWORD=changeme\n</code></pre>"},{"location":"deployment/docker-compose/#troubleshooting","title":"Troubleshooting","text":"<p>Services not starting: <pre><code>docker-compose logs\ndocker-compose ps\n</code></pre></p> <p>GPU not detected: <pre><code>docker run --rm --gpus all nvidia/cuda:12.0-base nvidia-smi\n</code></pre></p> <p>Out of memory: <pre><code># Increase Docker memory limit in Docker Desktop settings\n# Or adjust service limits in docker-compose.yml\n</code></pre></p>"},{"location":"deployment/docker-compose/#see-also","title":"See Also","text":"<ul> <li>Kubernetes Deployment</li> <li>Performance Tuning</li> <li>Security Guide</li> </ul>"},{"location":"deployment/kubernetes/","title":"Kubernetes Deployment Guide","text":"<p>Production deployment of Portalis on Kubernetes with GPU support.</p>"},{"location":"deployment/kubernetes/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Prerequisites</li> <li>Architecture</li> <li>Helm Chart Installation</li> <li>GPU Node Configuration</li> <li>Scaling Configuration</li> <li>High Availability</li> <li>Monitoring Integration</li> <li>Troubleshooting</li> </ul>"},{"location":"deployment/kubernetes/#prerequisites","title":"Prerequisites","text":""},{"location":"deployment/kubernetes/#required","title":"Required","text":"<ul> <li>Kubernetes 1.24+ cluster</li> <li>kubectl 1.24+</li> <li>Helm 3.8+</li> <li>Persistent Volume provisioner</li> <li>Ingress controller (NGINX recommended)</li> </ul>"},{"location":"deployment/kubernetes/#optional-for-gpu-acceleration","title":"Optional (for GPU acceleration)","text":"<ul> <li>NVIDIA GPU nodes</li> <li>NVIDIA Device Plugin</li> <li>CUDA 12.0+</li> <li>GPU-enabled container runtime</li> </ul>"},{"location":"deployment/kubernetes/#verify-prerequisites","title":"Verify Prerequisites","text":"<pre><code># Check Kubernetes version\nkubectl version --short\n\n# Check Helm version\nhelm version --short\n\n# Check GPU nodes (if applicable)\nkubectl get nodes -l nvidia.com/gpu=true\n\n# Check NVIDIA device plugin\nkubectl get pods -n kube-system | grep nvidia\n</code></pre>"},{"location":"deployment/kubernetes/#architecture","title":"Architecture","text":""},{"location":"deployment/kubernetes/#deployment-components","title":"Deployment Components","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Ingress (NGINX)                   \u2502\n\u2502            portalis.example.com \u2192 Service            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Portalis Service                    \u2502\n\u2502              LoadBalancer / ClusterIP                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Translation API    \u2502  NeMo Service  \u2502 CUDA Parser   \u2502\n\u2502  (3 replicas)      \u2502  (2 replicas)  \u2502 (1 replica)   \u2502\n\u2502  CPU pods          \u2502  GPU pods      \u2502 GPU pods      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              Persistent Storage (PVC)                \u2502\n\u2502        Cache | Models | Artifacts                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"deployment/kubernetes/#resource-distribution","title":"Resource Distribution","text":"Component CPU Memory GPU Replicas Translation API 500m-2 1-4Gi - 2-10 (HPA) NeMo Service 2-4 8-16Gi 1 2-4 CUDA Parser 1-2 2-4Gi 1 1-2 Triton Server 2-4 8-16Gi 1 2-4"},{"location":"deployment/kubernetes/#helm-chart-installation","title":"Helm Chart Installation","text":""},{"location":"deployment/kubernetes/#add-helm-repository","title":"Add Helm Repository","text":"<pre><code># Add Portalis Helm repository\nhelm repo add portalis https://charts.portalis.dev\nhelm repo update\n\n# Search for available versions\nhelm search repo portalis\n</code></pre>"},{"location":"deployment/kubernetes/#install-chart","title":"Install Chart","text":"<p>Basic Installation (CPU-only):</p> <pre><code>helm install portalis portalis/portalis \\\n  --namespace portalis \\\n  --create-namespace \\\n  --set gpu.enabled=false\n</code></pre> <p>Production Installation (with GPU):</p> <pre><code>helm install portalis portalis/portalis \\\n  --namespace portalis \\\n  --create-namespace \\\n  --set gpu.enabled=true \\\n  --set gpu.count=2 \\\n  --set replicaCount=3 \\\n  --set resources.requests.memory=4Gi \\\n  --set resources.requests.cpu=2 \\\n  --set persistence.enabled=true \\\n  --set persistence.size=50Gi\n</code></pre> <p>Custom Values File:</p> <p>Create <code>values.yaml</code>:</p> <pre><code># values.yaml\n\n# Number of replicas (auto-scaled)\nreplicaCount: 3\n\n# GPU configuration\ngpu:\n  enabled: true\n  count: 1  # GPUs per pod\n  type: nvidia.com/gpu\n\n# Resource limits\nresources:\n  requests:\n    memory: \"4Gi\"\n    cpu: \"2\"\n  limits:\n    memory: \"8Gi\"\n    cpu: \"4\"\n    nvidia.com/gpu: 1\n\n# Autoscaling\nautoscaling:\n  enabled: true\n  minReplicas: 2\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 70\n  targetMemoryUtilizationPercentage: 80\n\n# Persistent storage\npersistence:\n  enabled: true\n  storageClass: \"fast-ssd\"\n  size: 100Gi\n  mountPath: /data\n\n# Service configuration\nservice:\n  type: LoadBalancer\n  port: 80\n  targetPort: 8080\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: \"nlb\"\n\n# Ingress configuration\ningress:\n  enabled: true\n  className: nginx\n  annotations:\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n  hosts:\n    - host: portalis.example.com\n      paths:\n        - path: /\n          pathType: Prefix\n  tls:\n    - secretName: portalis-tls\n      hosts:\n        - portalis.example.com\n\n# NVIDIA services\nnemo:\n  enabled: true\n  replicaCount: 2\n  resources:\n    requests:\n      memory: \"8Gi\"\n      cpu: \"2\"\n      nvidia.com/gpu: 1\n    limits:\n      memory: \"16Gi\"\n      cpu: \"4\"\n      nvidia.com/gpu: 1\n\ntriton:\n  enabled: true\n  replicaCount: 3\n  modelRepository: /models\n  resources:\n    requests:\n      memory: \"8Gi\"\n      cpu: \"2\"\n      nvidia.com/gpu: 1\n\n# Monitoring\nmonitoring:\n  enabled: true\n  prometheus:\n    enabled: true\n  grafana:\n    enabled: true\n</code></pre> <p>Install with custom values:</p> <pre><code>helm install portalis portalis/portalis \\\n  --namespace portalis \\\n  --create-namespace \\\n  --values values.yaml\n</code></pre>"},{"location":"deployment/kubernetes/#verify-installation","title":"Verify Installation","text":"<pre><code># Check deployment status\nhelm status portalis -n portalis\n\n# Check pods\nkubectl get pods -n portalis\n\n# Check services\nkubectl get svc -n portalis\n\n# Check ingress\nkubectl get ingress -n portalis\n\n# Get service URL\nkubectl get svc portalis -n portalis -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'\n</code></pre>"},{"location":"deployment/kubernetes/#gpu-node-configuration","title":"GPU Node Configuration","text":""},{"location":"deployment/kubernetes/#install-nvidia-device-plugin","title":"Install NVIDIA Device Plugin","text":"<pre><code># Install NVIDIA device plugin\nkubectl create -f https://raw.githubusercontent.com/NVIDIA/k8s-device-plugin/v0.14.0/nvidia-device-plugin.yml\n\n# Verify installation\nkubectl get pods -n kube-system | grep nvidia\n\n# Expected output:\n# nvidia-device-plugin-daemonset-xxxxx   1/1     Running   0          5m\n</code></pre>"},{"location":"deployment/kubernetes/#label-gpu-nodes","title":"Label GPU Nodes","text":"<pre><code># List nodes\nkubectl get nodes\n\n# Label GPU nodes\nkubectl label nodes &lt;node-name&gt; nvidia.com/gpu=true\nkubectl label nodes &lt;node-name&gt; gpu-type=rtx4090\n\n# Verify labels\nkubectl get nodes -L nvidia.com/gpu,gpu-type\n</code></pre>"},{"location":"deployment/kubernetes/#create-gpu-node-pool-cloud-providers","title":"Create GPU Node Pool (Cloud Providers)","text":"<p>AWS (EKS):</p> <pre><code>eksctl create nodegroup \\\n  --cluster portalis-cluster \\\n  --name gpu-nodes \\\n  --node-type p3.2xlarge \\\n  --nodes 2 \\\n  --nodes-min 1 \\\n  --nodes-max 5 \\\n  --node-ami-family Ubuntu2004 \\\n  --node-labels nvidia.com/gpu=true\n</code></pre> <p>GCP (GKE):</p> <pre><code>gcloud container node-pools create gpu-pool \\\n  --cluster portalis-cluster \\\n  --accelerator type=nvidia-tesla-v100,count=1 \\\n  --machine-type n1-standard-4 \\\n  --num-nodes 2 \\\n  --enable-autoscaling \\\n  --min-nodes 1 \\\n  --max-nodes 5\n</code></pre> <p>Azure (AKS):</p> <pre><code>az aks nodepool add \\\n  --cluster-name portalis-cluster \\\n  --resource-group portalis-rg \\\n  --name gpupool \\\n  --node-count 2 \\\n  --node-vm-size Standard_NC6s_v3 \\\n  --enable-cluster-autoscaler \\\n  --min-count 1 \\\n  --max-count 5\n</code></pre>"},{"location":"deployment/kubernetes/#verify-gpu-availability","title":"Verify GPU Availability","text":"<pre><code># Run GPU test pod\nkubectl run gpu-test \\\n  --image=nvidia/cuda:12.0-base \\\n  --restart=Never \\\n  --rm -it \\\n  -- nvidia-smi\n\n# Expected output shows GPU information\n</code></pre>"},{"location":"deployment/kubernetes/#scaling-configuration","title":"Scaling Configuration","text":""},{"location":"deployment/kubernetes/#horizontal-pod-autoscaler-hpa","title":"Horizontal Pod Autoscaler (HPA)","text":"<p>Create HPA:</p> <pre><code># hpa.yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: portalis-hpa\n  namespace: portalis\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: portalis\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n      - type: Percent\n        value: 50\n        periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n      - type: Percent\n        value: 100\n        periodSeconds: 30\n      - type: Pods\n        value: 2\n        periodSeconds: 30\n</code></pre> <p>Apply HPA:</p> <pre><code>kubectl apply -f hpa.yaml\n\n# Monitor HPA\nkubectl get hpa -n portalis -w\n</code></pre>"},{"location":"deployment/kubernetes/#cluster-autoscaler","title":"Cluster Autoscaler","text":"<p>Enable cluster autoscaler for automatic node scaling:</p> <p>AWS (EKS):</p> <pre><code># Install cluster autoscaler\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/cluster-autoscaler/cloudprovider/aws/examples/cluster-autoscaler-autodiscover.yaml\n\n# Add IAM policy for autoscaler\n# Set auto-scaling group tags\n</code></pre> <p>GCP (GKE):</p> <pre><code># Enable autoscaling (already configured during node pool creation)\ngcloud container clusters update portalis-cluster \\\n  --enable-autoscaling \\\n  --min-nodes 3 \\\n  --max-nodes 10\n</code></pre>"},{"location":"deployment/kubernetes/#vertical-pod-autoscaler-vpa","title":"Vertical Pod Autoscaler (VPA)","text":"<p>For automatic resource adjustment:</p> <pre><code># vpa.yaml\napiVersion: autoscaling.k8s.io/v1\nkind: VerticalPodAutoscaler\nmetadata:\n  name: portalis-vpa\n  namespace: portalis\nspec:\n  targetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: portalis\n  updatePolicy:\n    updateMode: \"Auto\"\n  resourcePolicy:\n    containerPolicies:\n    - containerName: portalis\n      minAllowed:\n        cpu: 500m\n        memory: 1Gi\n      maxAllowed:\n        cpu: 4\n        memory: 8Gi\n</code></pre>"},{"location":"deployment/kubernetes/#high-availability","title":"High Availability","text":""},{"location":"deployment/kubernetes/#multi-zone-deployment","title":"Multi-Zone Deployment","text":"<p>Spread pods across availability zones:</p> <pre><code># deployment.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: portalis\nspec:\n  replicas: 3\n  template:\n    spec:\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - weight: 100\n            podAffinityTerm:\n              labelSelector:\n                matchExpressions:\n                - key: app\n                  operator: In\n                  values:\n                  - portalis\n              topologyKey: topology.kubernetes.io/zone\n</code></pre>"},{"location":"deployment/kubernetes/#pod-disruption-budget","title":"Pod Disruption Budget","text":"<p>Ensure minimum availability during updates:</p> <pre><code># pdb.yaml\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: portalis-pdb\n  namespace: portalis\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: portalis\n</code></pre> <p>Apply PDB:</p> <pre><code>kubectl apply -f pdb.yaml\n</code></pre>"},{"location":"deployment/kubernetes/#health-checks","title":"Health Checks","text":"<p>Configure liveness and readiness probes:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /health\n    port: 8080\n  initialDelaySeconds: 30\n  periodSeconds: 10\n  failureThreshold: 3\n\nreadinessProbe:\n  httpGet:\n    path: /ready\n    port: 8080\n  initialDelaySeconds: 10\n  periodSeconds: 5\n  failureThreshold: 2\n</code></pre>"},{"location":"deployment/kubernetes/#monitoring-integration","title":"Monitoring Integration","text":""},{"location":"deployment/kubernetes/#prometheus","title":"Prometheus","text":"<p>Install Prometheus:</p> <pre><code># Using Prometheus Operator\nhelm install prometheus prometheus-community/kube-prometheus-stack \\\n  --namespace monitoring \\\n  --create-namespace\n</code></pre> <p>ServiceMonitor:</p> <pre><code># servicemonitor.yaml\napiVersion: monitoring.coreos.com/v1\nkind: ServiceMonitor\nmetadata:\n  name: portalis\n  namespace: portalis\nspec:\n  selector:\n    matchLabels:\n      app: portalis\n  endpoints:\n  - port: metrics\n    interval: 30s\n    path: /metrics\n</code></pre>"},{"location":"deployment/kubernetes/#grafana-dashboards","title":"Grafana Dashboards","text":"<p>Import Portalis dashboards:</p> <pre><code># Get Grafana admin password\nkubectl get secret -n monitoring prometheus-grafana \\\n  -o jsonpath=\"{.data.admin-password}\" | base64 --decode\n\n# Port forward to Grafana\nkubectl port-forward -n monitoring svc/prometheus-grafana 3000:80\n\n# Open browser: http://localhost:3000\n# Import dashboard ID: 12345 (Portalis Translation Metrics)\n</code></pre>"},{"location":"deployment/kubernetes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/kubernetes/#pods-not-starting","title":"Pods Not Starting","text":"<pre><code># Check pod status\nkubectl get pods -n portalis\n\n# Describe pod\nkubectl describe pod &lt;pod-name&gt; -n portalis\n\n# Check logs\nkubectl logs &lt;pod-name&gt; -n portalis\n\n# Common issues:\n# - ImagePullBackOff: Check image registry credentials\n# - CrashLoopBackOff: Check application logs\n# - Pending: Check resource availability\n</code></pre>"},{"location":"deployment/kubernetes/#gpu-not-available","title":"GPU Not Available","text":"<pre><code># Check NVIDIA device plugin\nkubectl get pods -n kube-system | grep nvidia\n\n# Check GPU allocation\nkubectl describe node &lt;gpu-node&gt;\n\n# Test GPU\nkubectl run gpu-test --image=nvidia/cuda:12.0-base --rm -it -- nvidia-smi\n</code></pre>"},{"location":"deployment/kubernetes/#performance-issues","title":"Performance Issues","text":"<pre><code># Check resource usage\nkubectl top pods -n portalis\nkubectl top nodes\n\n# Check HPA status\nkubectl get hpa -n portalis\n\n# Check metrics\nkubectl get --raw /apis/metrics.k8s.io/v1beta1/nodes\n</code></pre>"},{"location":"deployment/kubernetes/#see-also","title":"See Also","text":"<ul> <li>Docker Compose Deployment</li> <li>Performance Tuning</li> <li>Security Guide</li> <li>Monitoring Setup</li> </ul>"}]}