"""
WASM Runtime Bridge using Wasmtime
Provides interface between Omniverse and WASM modules generated by Portalis
"""

import os
import time
import struct
from typing import Dict, List, Any, Optional, Tuple, Callable
from dataclasses import dataclass, field
from pathlib import Path
import numpy as np
import logging

try:
    from wasmtime import Store, Module, Instance, Func, FuncType, ValType, Engine, Config, WasiConfig
    WASMTIME_AVAILABLE = True
except ImportError:
    WASMTIME_AVAILABLE = False
    logging.warning("Wasmtime not available. Install with: pip install wasmtime")


@dataclass
class WasmModuleConfig:
    """Configuration for WASM module execution"""
    max_memory_mb: int = 512
    enable_wasi: bool = True
    enable_validation: bool = True
    optimization_level: str = "speed"  # "speed" or "size"
    enable_threads: bool = False
    enable_simd: bool = True
    cache_enabled: bool = True
    cache_dir: Optional[Path] = None


@dataclass
class WasmExecutionContext:
    """Execution context for WASM module"""
    module_path: Path
    instance: Any = None
    store: Any = None
    memory: Any = None
    exports: Dict[str, Any] = field(default_factory=dict)
    imports: Dict[str, Any] = field(default_factory=dict)
    execution_time_ms: float = 0.0
    memory_usage_mb: float = 0.0
    call_count: int = 0


@dataclass
class WasmFunctionSignature:
    """Type signature for WASM function"""
    name: str
    params: List[ValType]
    results: List[ValType]

    @classmethod
    def from_rust_signature(cls, name: str, rust_sig: str) -> 'WasmFunctionSignature':
        """Parse Rust function signature to WASM types"""
        # Example: "fn calculate(x: f64, y: f64) -> f64"
        params = []
        results = []

        # Simple parser for common types
        type_map = {
            'i32': ValType.i32(),
            'i64': ValType.i64(),
            'f32': ValType.f32(),
            'f64': ValType.f64(),
        }

        # Extract parameter types
        if '(' in rust_sig and ')' in rust_sig:
            params_str = rust_sig.split('(')[1].split(')')[0]
            for param in params_str.split(','):
                if ':' in param:
                    type_str = param.split(':')[1].strip()
                    params.append(type_map.get(type_str, ValType.i32()))

        # Extract return type
        if '->' in rust_sig:
            return_type = rust_sig.split('->')[1].strip()
            results.append(type_map.get(return_type, ValType.i32()))

        return cls(name=name, params=params, results=results)


class WasmtimeBridge:
    """
    Bridge between Omniverse and Wasmtime WASM runtime

    Provides high-level interface for:
    - Loading WASM modules
    - Executing functions
    - Memory management
    - Performance monitoring
    - Error handling
    """

    def __init__(self, config: WasmModuleConfig = None):
        if not WASMTIME_AVAILABLE:
            raise RuntimeError("Wasmtime not installed. Install with: pip install wasmtime")

        self.config = config or WasmModuleConfig()
        self.logger = logging.getLogger(__name__)

        # Initialize Wasmtime engine
        self.engine = self._create_engine()

        # Active contexts
        self.contexts: Dict[str, WasmExecutionContext] = {}

        # Performance metrics
        self.total_executions = 0
        self.total_execution_time_ms = 0.0

        self.logger.info("WasmtimeBridge initialized")

    def _create_engine(self) -> Engine:
        """Create Wasmtime engine with configuration"""
        config = Config()

        # Optimization settings
        if self.config.optimization_level == "speed":
            config.cranelift_opt_level("speed")
        else:
            config.cranelift_opt_level("size")

        # Feature flags
        config.wasm_simd(self.config.enable_simd)
        config.wasm_threads(self.config.enable_threads)

        # Caching
        if self.config.cache_enabled and self.config.cache_dir:
            config.cache_config_load_default()

        return Engine(config)

    def load_module(self, wasm_path: Path, module_id: str = None) -> str:
        """
        Load WASM module and create execution context

        Args:
            wasm_path: Path to .wasm file
            module_id: Optional identifier for the module

        Returns:
            Module ID string
        """
        wasm_path = Path(wasm_path)
        if not wasm_path.exists():
            raise FileNotFoundError(f"WASM module not found: {wasm_path}")

        module_id = module_id or wasm_path.stem

        start_time = time.perf_counter()

        try:
            # Load WASM module
            with open(wasm_path, 'rb') as f:
                wasm_bytes = f.read()

            module = Module(self.engine, wasm_bytes)

            # Create store
            store = Store(self.engine)

            # Configure WASI if enabled
            if self.config.enable_wasi:
                wasi_config = WasiConfig()
                wasi_config.inherit_stdout()
                wasi_config.inherit_stderr()
                store.set_wasi(wasi_config)

            # Create instance
            instance = Instance(store, module, [])

            # Extract exports
            exports = {}
            memory = None

            for export in module.exports:
                name = export.name
                export_item = instance.exports(store)[name]
                exports[name] = export_item

                # Track memory export
                if export.type.memory and name == "memory":
                    memory = export_item

            # Create execution context
            context = WasmExecutionContext(
                module_path=wasm_path,
                instance=instance,
                store=store,
                memory=memory,
                exports=exports
            )

            self.contexts[module_id] = context

            load_time_ms = (time.perf_counter() - start_time) * 1000

            self.logger.info(
                f"Loaded WASM module '{module_id}' from {wasm_path} "
                f"({len(exports)} exports, {load_time_ms:.2f}ms)"
            )

            return module_id

        except Exception as e:
            self.logger.error(f"Failed to load WASM module: {e}")
            raise

    def call_function(
        self,
        module_id: str,
        function_name: str,
        *args
    ) -> Any:
        """
        Call exported WASM function

        Args:
            module_id: Module identifier
            function_name: Name of exported function
            *args: Function arguments

        Returns:
            Function return value(s)
        """
        if module_id not in self.contexts:
            raise ValueError(f"Module '{module_id}' not loaded")

        context = self.contexts[module_id]

        if function_name not in context.exports:
            raise ValueError(
                f"Function '{function_name}' not found in module '{module_id}'. "
                f"Available: {list(context.exports.keys())}"
            )

        func = context.exports[function_name]

        if not isinstance(func, Func):
            raise ValueError(f"Export '{function_name}' is not a function")

        start_time = time.perf_counter()

        try:
            # Call function
            result = func(context.store, *args)

            # Update metrics
            execution_time_ms = (time.perf_counter() - start_time) * 1000
            context.execution_time_ms += execution_time_ms
            context.call_count += 1

            self.total_executions += 1
            self.total_execution_time_ms += execution_time_ms

            # Update memory usage
            if context.memory:
                memory_size = len(context.memory.data_ptr(context.store))
                context.memory_usage_mb = memory_size / (1024 * 1024)

            self.logger.debug(
                f"Called {function_name}({args}) = {result} "
                f"({execution_time_ms:.3f}ms)"
            )

            return result

        except Exception as e:
            self.logger.error(f"Error calling {function_name}: {e}")
            raise

    def call_function_array(
        self,
        module_id: str,
        function_name: str,
        input_array: np.ndarray
    ) -> np.ndarray:
        """
        Call WASM function with NumPy array input

        Transfers array to WASM memory and retrieves result

        Args:
            module_id: Module identifier
            function_name: Function name
            input_array: Input NumPy array

        Returns:
            Output NumPy array
        """
        context = self.contexts[module_id]

        if not context.memory:
            raise RuntimeError("Module has no exported memory")

        # Allocate memory in WASM (assume allocate function exists)
        if 'allocate' not in context.exports:
            raise RuntimeError("Module must export 'allocate' function")

        array_bytes = input_array.tobytes()
        array_len = len(array_bytes)

        # Allocate memory
        ptr = self.call_function(module_id, 'allocate', array_len)

        # Write array to memory
        memory_data = context.memory.data_ptr(context.store)
        memory_data[ptr:ptr + array_len] = array_bytes

        # Call processing function
        result_ptr = self.call_function(module_id, function_name, ptr, array_len)

        # Read result (assume same size)
        result_bytes = bytes(memory_data[result_ptr:result_ptr + array_len])
        result_array = np.frombuffer(result_bytes, dtype=input_array.dtype)

        # Free memory (assume free function exists)
        if 'free' in context.exports:
            self.call_function(module_id, 'free', ptr)
            self.call_function(module_id, 'free', result_ptr)

        return result_array

    def get_module_info(self, module_id: str) -> Dict[str, Any]:
        """Get information about loaded module"""
        if module_id not in self.contexts:
            raise ValueError(f"Module '{module_id}' not loaded")

        context = self.contexts[module_id]

        return {
            "module_id": module_id,
            "path": str(context.module_path),
            "exports": list(context.exports.keys()),
            "call_count": context.call_count,
            "total_execution_time_ms": context.execution_time_ms,
            "avg_execution_time_ms": (
                context.execution_time_ms / context.call_count
                if context.call_count > 0 else 0.0
            ),
            "memory_usage_mb": context.memory_usage_mb
        }

    def get_performance_stats(self) -> Dict[str, Any]:
        """Get overall performance statistics"""
        return {
            "total_executions": self.total_executions,
            "total_execution_time_ms": self.total_execution_time_ms,
            "avg_execution_time_ms": (
                self.total_execution_time_ms / self.total_executions
                if self.total_executions > 0 else 0.0
            ),
            "loaded_modules": len(self.contexts),
            "modules": {
                module_id: self.get_module_info(module_id)
                for module_id in self.contexts
            }
        }

    def unload_module(self, module_id: str):
        """Unload WASM module and free resources"""
        if module_id in self.contexts:
            context = self.contexts[module_id]

            self.logger.info(
                f"Unloading module '{module_id}' "
                f"({context.call_count} calls, "
                f"{context.execution_time_ms:.2f}ms total)"
            )

            del self.contexts[module_id]

    def unload_all(self):
        """Unload all modules"""
        module_ids = list(self.contexts.keys())
        for module_id in module_ids:
            self.unload_module(module_id)

    def __del__(self):
        """Cleanup on deletion"""
        self.unload_all()


# Convenience function
def create_wasm_bridge(
    cache_dir: Path = None,
    max_memory_mb: int = 512
) -> WasmtimeBridge:
    """Create configured WASM bridge"""
    config = WasmModuleConfig(
        max_memory_mb=max_memory_mb,
        cache_dir=cache_dir,
        cache_enabled=cache_dir is not None
    )
    return WasmtimeBridge(config)
